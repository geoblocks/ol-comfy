import{P as ae,T as ne,a as se,I as Ve,C as D,f as p,B as ce,p as Re,b as Be,s as je,c as U,E as ie,d as x,e as Y,g as he,M as V,h as F,i as S,j as R,k as le,t as I,l as Ne,m as Pe,n as Me,o as A,q as Ke,r as Ue,u as Oe,v as qe,F as He,w as We,x as Ye,y as ue,z as B,A as v,D as $e,G as Xe,H as ze,J as Je,S as re,K as Qe,L as Ze,O as et,V as tt,N as nt,Q as st,R as it,U as rt,W as ge,X as ot,Y as at}from"./background-layer-group-Spx6dEoP.js";import{F as O,R as De,V as Ae,a as be,b as q,c as ct}from"./Vector-CSKsS-9n.js";import{g as lt,a as dt,b as fe,I as Ge,D as _e}from"./interactionGroup-smC0vwqP.js";import{O as Le}from"./overlay-layer-group-B0SLy2fv.js";const $={TRANSLATESTART:"translatestart",TRANSLATING:"translating",TRANSLATEEND:"translateend"};class X extends ce{constructor(e,t,n,s,i){super(e),this.features=t,this.coordinate=n,this.startCoordinate=s,this.mapBrowserEvent=i}}class ht extends ae{constructor(e){e=e||{},super(e),this.on,this.once,this.un,this.lastCoordinate_=null,this.startCoordinate_=null,this.features_=e.features!==void 0?e.features:null;let t;if(e.layers&&!this.features_)if(typeof e.layers=="function")t=e.layers;else{const n=e.layers;t=function(s){return n.includes(s)}}else t=ne;this.layerFilter_=t,this.filter_=e.filter&&!this.features_?e.filter:ne,this.hitTolerance_=e.hitTolerance?e.hitTolerance:0,this.condition_=e.condition?e.condition:se,this.lastFeature_=null,this.addChangeListener(Ve.ACTIVE,this.handleActiveChanged_)}handleDownEvent(e){if(!e.originalEvent||!this.condition_(e))return!1;if(this.lastFeature_=this.featuresAtPixel_(e.pixel,e.map),!this.lastCoordinate_&&this.lastFeature_){this.startCoordinate_=e.coordinate,this.lastCoordinate_=e.coordinate,this.handleMoveEvent(e);const t=this.features_||new D([this.lastFeature_]);return this.dispatchEvent(new X($.TRANSLATESTART,t,e.coordinate,this.startCoordinate_,e)),!0}return!1}handleUpEvent(e){if(this.lastCoordinate_){this.lastCoordinate_=null,this.handleMoveEvent(e);const t=this.features_||new D([this.lastFeature_]);return this.dispatchEvent(new X($.TRANSLATEEND,t,e.coordinate,this.startCoordinate_,e)),this.startCoordinate_=null,!0}return!1}handleDragEvent(e){if(this.lastCoordinate_){const t=e.coordinate;e.map.getView().getProjection();const n=p(t),s=p(this.lastCoordinate_),i=n[0]-s[0],o=n[1]-s[1],r=this.features_||new D([this.lastFeature_]);r.forEach(function(a){const c=a.getGeometry();c.translate(i,o),a.setGeometry(c)}),this.lastCoordinate_=t,this.dispatchEvent(new X($.TRANSLATING,r,t,this.startCoordinate_,e))}}handleMoveEvent(e){const t=e.map.getViewport();this.featuresAtPixel_(e.pixel,e.map)?(t.classList.remove(this.lastCoordinate_?"ol-grab":"ol-grabbing"),t.classList.add(this.lastCoordinate_?"ol-grabbing":"ol-grab")):t.classList.remove("ol-grab","ol-grabbing")}featuresAtPixel_(e,t){return t.forEachFeatureAtPixel(e,(n,s)=>{if(!(!(n instanceof O)||!this.filter_(n,s))&&!(this.features_&&!this.features_.getArray().includes(n)))return n},{layerFilter:this.layerFilter_,hitTolerance:this.hitTolerance_})}getHitTolerance(){return this.hitTolerance_}setHitTolerance(e){this.hitTolerance_=e}setMap(e){const t=this.getMap();super.setMap(e),this.updateState_(t)}handleActiveChanged_(){this.updateState_(null)}updateState_(e){let t=this.getMap();const n=this.getActive();(!t||!n)&&(t=t||e,t&&t.getViewport().classList.remove("ol-grab","ol-grabbing"))}}const me=0,k=1,ye=[0,0,0,0],b=[],z={MODIFYSTART:"modifystart",MODIFYEND:"modifyend"};function J(l,e,t){let n;switch(e){case"LineString":n=l;break;case"MultiLineString":case"Polygon":n=l[t[0]];break;case"MultiPolygon":n=l[t[1]][t[0]];break}return n}class Q extends ce{constructor(e,t,n){super(e),this.features=t,this.mapBrowserEvent=n}}class ut extends ae{constructor(e){super(e),this.on,this.once,this.un,this.boundHandleFeatureChange_=this.handleFeatureChange_.bind(this),this.condition_=e.condition?e.condition:Re,this.defaultDeleteCondition_=function(n){return Be(n)&&je(n)},this.deleteCondition_=e.deleteCondition?e.deleteCondition:this.defaultDeleteCondition_,this.insertVertexCondition_=e.insertVertexCondition?e.insertVertexCondition:se,this.vertexFeature_=null,this.vertexSegments_=null,this.lastCoordinate_=[0,0],this.ignoreNextSingleClick_=!1,this.featuresBeingModified_=null,this.rBush_=new De,this.pixelTolerance_=e.pixelTolerance!==void 0?e.pixelTolerance:10,this.snappedToVertex_=!1,this.changingFeature_=!1,this.dragSegments_=[],this.overlay_=new Ae({source:new be({useSpatialIndex:!1,wrapX:!!e.wrapX}),style:e.style?e.style:ft(),updateWhileAnimating:!0,updateWhileInteracting:!0}),this.SEGMENT_WRITERS_={Point:this.writePointGeometry_.bind(this),LineString:this.writeLineStringGeometry_.bind(this),LinearRing:this.writeLineStringGeometry_.bind(this),Polygon:this.writePolygonGeometry_.bind(this),MultiPoint:this.writeMultiPointGeometry_.bind(this),MultiLineString:this.writeMultiLineStringGeometry_.bind(this),MultiPolygon:this.writeMultiPolygonGeometry_.bind(this),Circle:this.writeCircleGeometry_.bind(this),GeometryCollection:this.writeGeometryCollectionGeometry_.bind(this)},this.source_=null,this.traceSource_=e.traceSource||e.source||null,this.traceCondition_,this.setTrace(e.trace||!1),this.traceState_={active:!1},this.traceSegments_=null,this.hitDetection_=null;let t;if(e.features?t=e.features:e.source&&(this.source_=e.source,t=new D(this.source_.getFeatures()),this.source_.addEventListener(q.ADDFEATURE,this.handleSourceAdd_.bind(this)),this.source_.addEventListener(q.REMOVEFEATURE,this.handleSourceRemove_.bind(this))),!t)throw new Error("The modify interaction requires features, a source or a layer");e.hitDetection&&(this.hitDetection_=e.hitDetection),this.features_=t,this.features_.forEach(this.addFeature_.bind(this)),this.features_.addEventListener(U.ADD,this.handleFeatureAdd_.bind(this)),this.features_.addEventListener(U.REMOVE,this.handleFeatureRemove_.bind(this)),this.lastPointerEvent_=null,this.delta_=[0,0],this.snapToPointer_=e.snapToPointer===void 0?!this.hitDetection_:e.snapToPointer}setTrace(e){let t;e?e===!0?t=se:t=e:t=Ue,this.traceCondition_=t}addFeature_(e){const t=e.getGeometry();if(t){const s=this.SEGMENT_WRITERS_[t.getType()];s&&s(e,t)}const n=this.getMap();n&&n.isRendered()&&this.getActive()&&this.handlePointerAtPixel_(this.lastCoordinate_),e.addEventListener(ie.CHANGE,this.boundHandleFeatureChange_)}willModifyFeatures_(e,t){if(!this.featuresBeingModified_){this.featuresBeingModified_=new D;const n=this.featuresBeingModified_.getArray();for(let s=0,i=t.length;s<i;++s){const o=t[s].feature;o&&!n.includes(o)&&this.featuresBeingModified_.push(o)}this.featuresBeingModified_.getLength()===0?this.featuresBeingModified_=null:this.dispatchEvent(new Q(z.MODIFYSTART,this.featuresBeingModified_,e))}}removeFeature_(e){this.removeFeatureSegmentData_(e),this.vertexFeature_&&this.features_.getLength()===0&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null),e.removeEventListener(ie.CHANGE,this.boundHandleFeatureChange_)}removeFeatureSegmentData_(e){const t=this.rBush_,n=[];t.forEach(function(s){e===s.feature&&n.push(s)});for(let s=n.length-1;s>=0;--s){const i=n[s];for(let o=this.dragSegments_.length-1;o>=0;--o)this.dragSegments_[o][0]===i&&this.dragSegments_.splice(o,1);t.remove(i)}}setActive(e){this.vertexFeature_&&!e&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null),super.setActive(e)}setMap(e){this.overlay_.setMap(e),super.setMap(e)}getOverlay(){return this.overlay_}handleSourceAdd_(e){e.feature&&this.features_.push(e.feature)}handleSourceRemove_(e){e.feature&&this.features_.remove(e.feature)}handleFeatureAdd_(e){this.addFeature_(e.element)}handleFeatureChange_(e){if(!this.changingFeature_){const t=e.target;this.removeFeature_(t),this.addFeature_(t)}}handleFeatureRemove_(e){this.removeFeature_(e.element)}writePointGeometry_(e,t){const n=t.getCoordinates(),s={feature:e,geometry:t,segment:[n,n]};this.rBush_.insert(t.getExtent(),s)}writeMultiPointGeometry_(e,t){const n=t.getCoordinates();for(let s=0,i=n.length;s<i;++s){const o=n[s],r={feature:e,geometry:t,depth:[s],index:s,segment:[o,o]};this.rBush_.insert(t.getExtent(),r)}}writeLineStringGeometry_(e,t){const n=t.getCoordinates();for(let s=0,i=n.length-1;s<i;++s){const o=n.slice(s,s+2),r={feature:e,geometry:t,index:s,segment:o};this.rBush_.insert(x(o),r)}}writeMultiLineStringGeometry_(e,t){const n=t.getCoordinates();for(let s=0,i=n.length;s<i;++s){const o=n[s];for(let r=0,a=o.length-1;r<a;++r){const c=o.slice(r,r+2),d={feature:e,geometry:t,depth:[s],index:r,segment:c};this.rBush_.insert(x(c),d)}}}writePolygonGeometry_(e,t){const n=t.getCoordinates();for(let s=0,i=n.length;s<i;++s){const o=n[s];for(let r=0,a=o.length-1;r<a;++r){const c=o.slice(r,r+2),d={feature:e,geometry:t,depth:[s],index:r,segment:c};this.rBush_.insert(x(c),d)}}}writeMultiPolygonGeometry_(e,t){const n=t.getCoordinates();for(let s=0,i=n.length;s<i;++s){const o=n[s];for(let r=0,a=o.length;r<a;++r){const c=o[r];for(let d=0,g=c.length-1;d<g;++d){const h=c.slice(d,d+2),u={feature:e,geometry:t,depth:[r,s],index:d,segment:h};this.rBush_.insert(x(h),u)}}}}writeCircleGeometry_(e,t){const n=t.getCenter(),s={feature:e,geometry:t,index:me,segment:[n,n]},i={feature:e,geometry:t,index:k,segment:[n,n]},o=[s,i];s.featureSegments=o,i.featureSegments=o,this.rBush_.insert(Y(n),s);let r=t;this.rBush_.insert(r.getExtent(),i)}writeGeometryCollectionGeometry_(e,t){const n=t.getGeometriesArray();for(let s=0;s<n.length;++s){const i=n[s],o=this.SEGMENT_WRITERS_[i.getType()];o(e,i)}}createOrUpdateVertexFeature_(e,t,n,s){let i=this.vertexFeature_;return i?i.getGeometry().setCoordinates(e):(i=new O(new he(e)),this.vertexFeature_=i,this.overlay_.getSource().addFeature(i)),i.set("features",t),i.set("geometries",n),i.set("existing",s),i}handleEvent(e){if(!e.originalEvent)return!0;this.lastPointerEvent_=e;let t;return!e.map.getView().getInteracting()&&e.type==V.POINTERMOVE&&!this.handlingDownUpSequence&&this.handlePointerMove_(e),this.vertexFeature_&&this.deleteCondition_(e)&&(e.type!=V.SINGLECLICK||!this.ignoreNextSingleClick_?t=this.removePoint():t=!0),e.type==V.SINGLECLICK&&(this.ignoreNextSingleClick_=!1),super.handleEvent(e)&&!t}findInsertVerticesAndUpdateDragSegments_(e){if(this.handlePointerAtPixel_(e),this.dragSegments_.length=0,this.featuresBeingModified_=null,!this.vertexFeature_)return;this.getMap().getView().getProjection();const n=[],s=this.vertexFeature_.getGeometry().getCoordinates(),i=x([s]),o=this.rBush_.getInExtent(i),r={};o.sort(gt);for(let a=0,c=o.length;a<c;++a){const d=o[a],g=d.segment;let h=F(d.geometry);const u=d.depth;if(u&&(h+="-"+u.join("-")),r[h]||(r[h]=new Array(2)),d.geometry.getType()==="Circle"&&d.index===k){const f=xe(e,d);S(f,s)&&!r[h][0]&&(this.dragSegments_.push([d,0]),r[h][0]=d);continue}if(S(g[0],s)&&!r[h][0]){this.dragSegments_.push([d,0]),r[h][0]=d;continue}if(S(g[1],s)&&!r[h][1]){if(r[h][0]&&r[h][0].index===0){let f=d.geometry.getCoordinates();switch(d.geometry.getType()){case"LineString":case"MultiLineString":continue;case"MultiPolygon":f=f[u[1]];case"Polygon":if(d.index!==f[u[0]].length-2)continue;break}}this.dragSegments_.push([d,1]),r[h][1]=d;continue}F(g)in this.vertexSegments_&&!r[h][0]&&!r[h][1]&&n.push(d)}return n}deactivateTrace_(){this.traceState_={active:!1}}updateTrace_(e){const t=this.traceState_;if(!t.active)return;if(t.targetIndex===-1){const i=e.map.getPixelFromCoordinate(t.startCoord);if(R(i,e.pixel)<this.pixelTolerance_)return}const n=lt(e.coordinate,t,e.map,this.pixelTolerance_);if(t.targetIndex===-1&&Math.sqrt(n.closestTargetDistance)/e.map.getView().getResolution()>this.pixelTolerance_)return;if(t.targetIndex!==n.index){if(t.targetIndex!==-1){const o=t.targets[t.targetIndex];this.removeTracedCoordinates_(o.startIndex,o.endIndex)}else for(const o of this.traceSegments_){const r=o[0],a=r.geometry,c=o[1],d=a.getCoordinates();J(d,a.getType(),r.depth).splice(r.index+c,1),a.setCoordinates(d),c===0&&(r.index-=1)}const i=t.targets[n.index];this.addTracedCoordinates_(i,i.startIndex,n.endIndex)}else{const i=t.targets[t.targetIndex];this.addOrRemoveTracedCoordinates_(i,n.endIndex)}t.targetIndex=n.index;const s=t.targets[t.targetIndex];s.endIndex=n.endIndex}getTraceCandidates_(e){const t=this.getMap(),n=this.pixelTolerance_,s=t.getCoordinateFromPixel([e.pixel[0]-n,e.pixel[1]+n]),i=t.getCoordinateFromPixel([e.pixel[0]+n,e.pixel[1]-n]),o=x([s,i]);return this.traceSource_.getFeaturesInExtent(o)}toggleTraceState_(e){if(!this.traceSource_||!this.traceCondition_(e))return;if(this.traceState_.active){this.deactivateTrace_(),this.traceSegments_=null;return}const t=this.getTraceCandidates_(e);if(t.length===0)return;const n=dt(e.coordinate,t);n.length&&(this.traceState_={active:!0,startCoord:e.coordinate.slice(),targets:n,targetIndex:-1})}addOrRemoveTracedCoordinates_(e,t){const n=e.startIndex<=e.endIndex,s=e.startIndex<=t;n===s?n&&t>e.endIndex||!n&&t<e.endIndex?this.addTracedCoordinates_(e,e.endIndex,t):(n&&t<e.endIndex||!n&&t>e.endIndex)&&this.removeTracedCoordinates_(t,e.endIndex):(this.removeTracedCoordinates_(e.startIndex,e.endIndex),this.addTracedCoordinates_(e,e.startIndex,t))}removeTracedCoordinates_(e,t){if(e===t)return;let n=0;if(e<t){const s=Math.ceil(e);let i=Math.floor(t);i===t&&(i-=1),n=i-s+1}else{const s=Math.floor(e);let i=Math.ceil(t);i===t&&(i+=1),n=s-i+1}if(n>0)for(const s of this.traceSegments_){const i=s[0],o=i.geometry,r=s[1];let a=s[0].index+1;r===1&&(a-=n);const c=o.getCoordinates();J(c,o.getType(),i.depth).splice(a,n),o.setCoordinates(c),r===1&&(i.index-=n)}}addTracedCoordinates_(e,t,n){if(t===n)return;const s=[];if(t<n){const i=Math.ceil(t);let o=Math.floor(n);o===n&&(o-=1);for(let r=i;r<=o;++r)s.push(fe(e.coordinates,r))}else{const i=Math.floor(t);let o=Math.ceil(n);o===n&&(o+=1);for(let r=i;r>=o;--r)s.push(fe(e.coordinates,r))}if(s.length)for(const i of this.traceSegments_){const o=i[0],r=o.geometry,a=i[1],c=o.index+1;a===0&&s.reverse();const d=r.getCoordinates();J(d,r.getType(),o.depth).splice(c,0,...s),r.setCoordinates(d),a===1&&(o.index+=s.length)}}updateGeometry_(e,t){const n=t[0],s=n.depth;let i;const o=n.segment,r=n.geometry,a=t[1];for(;e.length<r.getStride();)e.push(o[a][e.length]);switch(r.getType()){case"Point":i=e,o[0]=e,o[1]=e;break;case"MultiPoint":i=r.getCoordinates(),i[n.index]=e,o[0]=e,o[1]=e;break;case"LineString":i=r.getCoordinates(),i[n.index+a]=e,o[a]=e;break;case"MultiLineString":i=r.getCoordinates(),i[s[0]][n.index+a]=e,o[a]=e;break;case"Polygon":i=r.getCoordinates(),i[s[0]][n.index+a]=e,o[a]=e;break;case"MultiPolygon":i=r.getCoordinates(),i[s[1]][s[0]][n.index+a]=e,o[a]=e;break;case"Circle":const c=r;if(o[0]=e,o[1]=e,n.index===me)this.changingFeature_=!0,c.setCenter(e),this.changingFeature_=!1;else{this.changingFeature_=!0,this.getMap().getView().getProjection();let d=R(p(c.getCenter()),p(e));c.setRadius(d),this.changingFeature_=!1}break}i&&this.setGeometryCoordinates_(r,i)}handleDragEvent(e){this.ignoreNextSingleClick_=!1,this.willModifyFeatures_(e,this.dragSegments_.map(([o])=>o));const t=[e.coordinate[0]+this.delta_[0],e.coordinate[1]+this.delta_[1]],n=[],s=[],i=this.traceState_.active&&!this.traceSegments_?this.traceState_.startCoord:null;if(i){this.traceSegments_=[];for(const o of this.dragSegments_){const r=o[0];R(le(i,r.segment),i)/e.map.getView().getResolution()<1&&this.traceSegments_.push(o)}}for(let o=0,r=this.dragSegments_.length;o<r;++o){const a=this.dragSegments_[o],c=a[0],d=c.feature;n.includes(d)||n.push(d);const g=c.geometry;s.includes(g)||s.push(g),this.updateGeometry_(t,a)}this.updateTrace_(e),this.createOrUpdateVertexFeature_(t,n,s,!0)}handleDownEvent(e){if(!this.condition_(e))return!1;const t=e.coordinate,n=this.findInsertVerticesAndUpdateDragSegments_(t);if(n?.length&&this.insertVertexCondition_(e)&&(this.willModifyFeatures_(e,n),this.vertexFeature_)){const s=this.vertexFeature_.getGeometry().getCoordinates();for(let i=n.length-1;i>=0;--i)this.insertVertex_(n[i],s);this.ignoreNextSingleClick_=!0}return!!this.vertexFeature_}handleUpEvent(e){for(let t=this.dragSegments_.length-1;t>=0;--t){const n=this.dragSegments_[t][0],s=n.geometry;if(s.getType()==="Circle"){const i=s,o=i.getCenter(),r=n.featureSegments[0],a=n.featureSegments[1];r.segment[0]=o,r.segment[1]=o,a.segment[0]=o,a.segment[1]=o,this.rBush_.update(Y(o),r);let c=i;this.rBush_.update(c.getExtent(),a)}else this.rBush_.update(x(n.segment),n)}return this.featuresBeingModified_&&(this.toggleTraceState_(e),this.dispatchEvent(new Q(z.MODIFYEND,this.featuresBeingModified_,e)),this.featuresBeingModified_=null),!1}handlePointerMove_(e){this.lastCoordinate_=e.coordinate,this.handlePointerAtPixel_(this.lastCoordinate_)}handlePointerAtPixel_(e){const t=this.getMap(),n=t.getPixelFromCoordinate(e);t.getView().getProjection();const s=function(r,a){return pe(e,r)-pe(e,a)};let i,o;if(this.hitDetection_){const r=typeof this.hitDetection_=="object"?a=>a===this.hitDetection_:void 0;t.forEachFeatureAtPixel(n,(a,c,d)=>{d&&d.getType()==="Point"&&(d=new he(I(d.getCoordinates())));const g=d||a.getGeometry();if(g&&g.getType()==="Point"&&a instanceof O&&this.features_.getArray().includes(a)){o=g;const h=a.getGeometry().getFlatCoordinates().slice(0,2);i=[{feature:a,geometry:o,segment:[h,h]}]}return!0},{layerFilter:r})}if(!i){const r=Ne(Y(e,ye)),a=t.getView().getResolution()*this.pixelTolerance_,c=Pe(Me(r,a,ye));i=this.rBush_.getInExtent(c)}if(i&&i.length>0){const r=i.sort(s)[0],a=r.segment;let c=xe(e,r);const d=t.getPixelFromCoordinate(c);let g=R(n,d);if(o||g<=this.pixelTolerance_){const h={};if(h[F(a)]=!0,this.snapToPointer_||(this.delta_[0]=c[0]-e[0],this.delta_[1]=c[1]-e[1]),r.geometry.getType()==="Circle"&&r.index===k)this.snappedToVertex_=!0,this.createOrUpdateVertexFeature_(c,[r.feature],[r.geometry],this.snappedToVertex_);else{const u=t.getPixelFromCoordinate(a[0]),f=t.getPixelFromCoordinate(a[1]),m=A(d,u),_=A(d,f);if(g=Math.sqrt(Math.min(m,_)),this.snappedToVertex_=g<=this.pixelTolerance_,!this.snappedToVertex_&&!this.insertVertexCondition_(this.lastPointerEvent_)){this.vertexFeature_&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null);return}this.snappedToVertex_&&(c=m>_?a[1]:a[0]),this.createOrUpdateVertexFeature_(c,[r.feature],[r.geometry],this.snappedToVertex_);const y={};y[F(r.geometry)]=!0;for(let C=1,w=i.length;C<w;++C){const L=i[C].segment;if(S(a[0],L[0])&&S(a[1],L[1])||S(a[0],L[1])&&S(a[1],L[0])){const de=F(i[C].geometry);de in y||(y[de]=!0,h[F(L)]=!0)}else break}}this.vertexSegments_=h;return}}this.vertexFeature_&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null)}insertVertex_(e,t){const n=e.segment,s=e.feature,i=e.geometry,o=e.depth,r=e.index;let a;for(;t.length<i.getStride();)t.push(0);switch(i.getType()){case"MultiLineString":a=i.getCoordinates(),a[o[0]].splice(r+1,0,t);break;case"Polygon":a=i.getCoordinates(),a[o[0]].splice(r+1,0,t);break;case"MultiPolygon":a=i.getCoordinates(),a[o[1]][o[0]].splice(r+1,0,t);break;case"LineString":a=i.getCoordinates(),a.splice(r+1,0,t);break;default:return!1}this.setGeometryCoordinates_(i,a);const c=this.rBush_;c.remove(e),this.updateSegmentIndices_(i,r,o,1);const d={segment:[n[0],t],feature:s,geometry:i,depth:o,index:r};c.insert(x(d.segment),d),this.dragSegments_.push([d,1]);const g={segment:[t,n[1]],feature:s,geometry:i,depth:o,index:r+1};return c.insert(x(g.segment),g),this.dragSegments_.push([g,0]),!0}updatePointer_(e){return e&&this.findInsertVerticesAndUpdateDragSegments_(e),this.vertexFeature_?.getGeometry().getCoordinates()}getPoint(){const e=this.vertexFeature_?.getGeometry().getCoordinates();return e?I(e,this.getMap().getView().getProjection()):null}canRemovePoint(){if(!this.vertexFeature_||this.vertexFeature_.get("geometries").every(n=>n.getType()==="Circle"||n.getType().endsWith("Point")))return!1;const e=this.vertexFeature_.getGeometry().getCoordinates();return this.rBush_.getInExtent(x([e])).some(({segment:n})=>S(n[0],e)||S(n[1],e))}removePoint(e){if(e&&(e=p(e,this.getMap().getView().getProjection()),this.updatePointer_(e)),!this.lastPointerEvent_||this.lastPointerEvent_&&this.lastPointerEvent_.type!=V.POINTERDRAG){const t=this.lastPointerEvent_;this.willModifyFeatures_(t,this.dragSegments_.map(([s])=>s));const n=this.removeVertex_();return this.featuresBeingModified_&&this.dispatchEvent(new Q(z.MODIFYEND,this.featuresBeingModified_,t)),this.featuresBeingModified_=null,n}return!1}removeVertex_(){const e=this.dragSegments_,t={};let n=!1,s,i,o,r,a,c,d,g,h,u,f;for(a=e.length-1;a>=0;--a)o=e[a],u=o[0],f=F(u.feature),u.depth&&(f+="-"+u.depth.join("-")),f in t||(t[f]={}),o[1]===0?(t[f].right=u,t[f].index=u.index):o[1]==1&&(t[f].left=u,t[f].index=u.index+1);for(f in t){switch(h=t[f].right,d=t[f].left,c=t[f].index,g=c-1,d!==void 0?u=d:u=h,g<0&&(g=0),r=u.geometry,i=r.getCoordinates(),s=i,n=!1,r.getType()){case"MultiLineString":i[u.depth[0]].length>2&&(i[u.depth[0]].splice(c,1),n=!0);break;case"LineString":i.length>2&&(i.splice(c,1),n=!0);break;case"MultiPolygon":s=s[u.depth[1]];case"Polygon":s=s[u.depth[0]],s.length>4&&(c==s.length-1&&(c=0),s.splice(c,1),n=!0,c===0&&(s.pop(),s.push(s[0]),g=s.length-1));break}if(n){this.setGeometryCoordinates_(r,i);const m=[];if(d!==void 0&&(this.rBush_.remove(d),m.push(d.segment[0])),h!==void 0&&(this.rBush_.remove(h),m.push(h.segment[1])),d!==void 0&&h!==void 0){const _={depth:u.depth,feature:u.feature,geometry:u.geometry,index:g,segment:m};this.rBush_.insert(x(_.segment),_)}this.updateSegmentIndices_(r,c,u.depth,-1),this.vertexFeature_&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null),e.length=0}}return n}canInsertPoint(){if(!this.vertexFeature_||this.vertexFeature_.get("geometries").every(n=>n.getType()==="Circle"||n.getType().endsWith("Point")))return!1;const e=this.vertexFeature_.getGeometry().getCoordinates();return this.rBush_.getInExtent(x([e])).some(({segment:n})=>!(S(n[0],e)||S(n[1],e)))}insertPoint(e){const t=e?p(e,this.getMap().getView().getProjection()):this.vertexFeature_?.getGeometry().getCoordinates();return t?this.findInsertVerticesAndUpdateDragSegments_(t).reduce((s,i)=>s||this.insertVertex_(i,t),!1):!1}setGeometryCoordinates_(e,t){this.changingFeature_=!0,e.setCoordinates(t),this.changingFeature_=!1}updateSegmentIndices_(e,t,n,s){this.rBush_.forEachInExtent(e.getExtent(),function(i){i.geometry===e&&(n===void 0||i.depth===void 0||Ke(i.depth,n))&&i.index>t&&(i.index+=s)})}}function gt(l,e){return l.index-e.index}function pe(l,e,t){const n=e.geometry;if(n.getType()==="Circle"){let i=n;if(e.index===k){const o=A(i.getCenter(),p(l)),r=Math.sqrt(o)-i.getRadius();return r*r}}const s=p(l);return b[0]=p(e.segment[0]),b[1]=p(e.segment[1]),qe(s,b)}function xe(l,e,t){const n=e.geometry;if(n.getType()==="Circle"&&e.index===k)return I(n.getClosestPoint(p(l)));const s=p(l);return b[0]=p(e.segment[0]),b[1]=p(e.segment[1]),I(le(s,b))}function ft(){const l=Oe();return function(e,t){return l.Point}}const Z={SNAP:"snap",UNSNAP:"unsnap"};class ee extends ce{constructor(e,t){super(e),this.vertex=t.vertex,this.vertexPixel=t.vertexPixel,this.feature=t.feature,this.segment=t.segment}}const ke={Circle(l,e){const n=ze(l);return ke.Polygon(n)},GeometryCollection(l,e){const t=[],n=l.getGeometriesArray();for(let s=0;s<n.length;++s){const i=this[n[s].getType()];i&&t.push(i(n[s],e))}return t.flat()},LineString(l){const e=[],t=l.getFlatCoordinates(),n=l.getStride();for(let s=0,i=t.length-n;s<i;s+=n)e.push([t.slice(s,s+2),t.slice(s+n,s+n+2)]);return e},MultiLineString(l){const e=[],t=l.getFlatCoordinates(),n=l.getStride(),s=l.getEnds();let i=0;for(let o=0,r=s.length;o<r;++o){const a=s[o];for(let c=i,d=a-n;c<d;c+=n)e.push([t.slice(c,c+2),t.slice(c+n,c+n+2)]);i=a}return e},MultiPoint(l){const e=[],t=l.getFlatCoordinates(),n=l.getStride();for(let s=0,i=t.length;s<i;s+=n)e.push([t.slice(s,s+2)]);return e},MultiPolygon(l){const e=[],t=l.getFlatCoordinates(),n=l.getStride(),s=l.getEndss();let i=0;for(let o=0,r=s.length;o<r;++o){const a=s[o];for(let c=0,d=a.length;c<d;++c){const g=a[c];for(let h=i,u=g-n;h<u;h+=n)e.push([t.slice(h,h+2),t.slice(h+n,h+n+2)]);i=g}}return e},Point(l){return[[l.getFlatCoordinates().slice(0,2)]]},Polygon(l){const e=[],t=l.getFlatCoordinates(),n=l.getStride(),s=l.getEnds();let i=0;for(let o=0,r=s.length;o<r;++o){const a=s[o];for(let c=i,d=a-n;c<d;c+=n)e.push([t.slice(c,c+2),t.slice(c+n,c+n+2)]);i=a}return e}};function Ce(l){return l.feature?l.feature:l.element?l.element:null}const te=[],T=[],M=[];class _t extends ae{constructor(e){e=e||{},super({handleDownEvent:ne,stopDown:He}),this.on,this.once,this.un,this.source_=e.source?e.source:null,this.vertex_=e.vertex!==void 0?e.vertex:!0,this.edge_=e.edge!==void 0?e.edge:!0,this.intersection_=e.intersection!==void 0?e.intersection:!1,this.features_=e.features?e.features:null,this.featuresListenerKeys_=[],this.featureChangeListenerKeys_={},this.indexedFeaturesExtents_={},this.pendingFeatures_={},this.pixelTolerance_=e.pixelTolerance!==void 0?e.pixelTolerance:10,this.rBush_=new De,this.snapped_=null,this.segmenters_=Object.assign({},ke,e.segmenters)}addFeature(e,t){t=t!==void 0?t:!0;const n=F(e),s=e.getGeometry();if(s){const i=this.segmenters_[s.getType()];if(i){this.indexedFeaturesExtents_[n]=s.getExtent(We());const o=i.call(this.segmenters_,s,this.getMap().getView().getProjection());let r=o.length;for(let a=0;a<r;++a){const c=o[a];T[a]=x(c),M[a]={feature:e,segment:c}}if(this.intersection_)for(let a=0,c=o.length;a<c;++a){const d=o[a];if(d.length===1)continue;const g=T[a];for(let u=0,f=a-1;u<f;++u){const m=o[u];if(!Ye(g,T[u]))continue;const _=ue(d,m);if(!_)continue;const y=[_];T[r]=x(y),M[r++]={feature:e,intersectionFeature:e,segment:y}}const h=this.rBush_.getInExtent(T[a]);for(let u=0,f=h.length;u<f;++u){const m=h[u].segment;if(m.length===1)continue;const _=ue(d,m);if(!_)continue;const y=[_];T[r]=x(y),M[r++]={feature:e,intersectionFeature:h[u].feature,segment:y}}}r===1?this.rBush_.insert(T[0],M[0]):(T.length=r,M.length=r,this.rBush_.load(T,M))}}t&&(this.featureChangeListenerKeys_[n]&&B(this.featureChangeListenerKeys_[n]),this.featureChangeListenerKeys_[n]=v(e,ie.CHANGE,this.handleFeatureChange_,this))}getFeatures_(){let e;return this.features_?e=this.features_:this.source_&&(e=this.source_.getFeatures()),e}areSnapDataEqual_(e,t){return e.segment===t.segment&&e.feature===t.feature}handleEvent(e){const t=this.snapTo(e.pixel,e.coordinate,e.map);return t?(e.coordinate=t.vertex.slice(0,2),e.pixel=t.vertexPixel,this.snapped_&&!this.areSnapDataEqual_(this.snapped_,t)&&this.dispatchEvent(new ee(Z.UNSNAP,this.snapped_)),this.snapped_={vertex:e.coordinate,vertexPixel:e.pixel,feature:t.feature,segment:t.segment},this.dispatchEvent(new ee(Z.SNAP,this.snapped_))):this.snapped_&&(this.dispatchEvent(new ee(Z.UNSNAP,this.snapped_)),this.snapped_=null),super.handleEvent(e)}handleFeatureAdd_(e){const t=Ce(e);t&&this.addFeature(t)}handleFeatureRemove_(e){const t=Ce(e);t&&(this.removeFeature(t),delete this.pendingFeatures_[F(t)])}handleFeatureChange_(e){const t=e.target;this.handlingDownUpSequence?this.pendingFeatures_[F(t)]=t:this.updateFeature_(t)}handleUpEvent(e){const t=Object.values(this.pendingFeatures_);if(t.length){for(const n of t)this.updateFeature_(n);$e(this.pendingFeatures_)}return!1}removeFeature(e,t){const n=t!==void 0?t:!0,s=F(e),i=this.indexedFeaturesExtents_[s];if(i){const o=this.rBush_;o.getInExtent(i).forEach(r=>{(e===r.feature||e===r.intersectionFeature)&&o.remove(r)})}n&&(B(this.featureChangeListenerKeys_[s]),delete this.featureChangeListenerKeys_[s])}setMap(e){const t=this.getMap(),n=this.featuresListenerKeys_;let s=this.getFeatures_();if(Array.isArray(s)||(s=s.getArray()),t&&(n.forEach(B),n.length=0,this.rBush_.clear(),Object.values(this.featureChangeListenerKeys_).forEach(B),this.featureChangeListenerKeys_={}),super.setMap(e),e){this.features_?n.push(v(this.features_,U.ADD,this.handleFeatureAdd_,this),v(this.features_,U.REMOVE,this.handleFeatureRemove_,this)):this.source_&&n.push(v(this.source_,q.ADDFEATURE,this.handleFeatureAdd_,this),v(this.source_,q.REMOVEFEATURE,this.handleFeatureRemove_,this));for(const i of s)this.addFeature(i)}}snapTo(e,t,n){n.getView().getProjection();const s=p(t),i=Pe(Me(x([s]),n.getView().getResolution()*this.pixelTolerance_)),o=this.rBush_.getInExtent(i),r=o.length;if(r===0)return null;let a,c=1/0,d,g=null;const h=this.pixelTolerance_*this.pixelTolerance_,u=()=>{if(!a)return null;const f=n.getPixelFromCoordinate(a);return A(e,f)>h?null:{vertex:a,vertexPixel:[Math.round(f[0]),Math.round(f[1])],feature:d,segment:g}};if(this.vertex_||this.intersection_){for(let m=0;m<r;++m){const _=o[m];if(_.feature.getGeometry().getType()!=="Circle")for(const y of _.segment){const C=p(y),w=A(s,C);w<c&&(this.intersection_&&_.intersectionFeature||this.vertex_&&!_.intersectionFeature)&&(a=y,c=w,d=_.feature)}}const f=u();if(f)return f}if(this.edge_){for(let m=0;m<r;++m){let _=null;const y=o[m];if(y.feature.getGeometry().getType()==="Circle"){let C=y.feature.getGeometry();_=Xe(s,C)}else{const[C,w]=y.segment;w&&(te[0]=p(C),te[1]=p(w),_=le(s,te))}if(_){const C=A(s,_);C<c&&(a=I(_),g=y.feature.getGeometry().getType()==="Circle"?null:y.segment,c=C,d=y.feature)}}const f=u();if(f)return f}return null}updateFeature_(e){this.removeFeature(e,!1),this.addFeature(e,!1)}}const mt=l=>e=>l(),yt=(l,e)=>t=>l(t)?(e(t),!0):!1,pt=l=>{l.forEach(e=>Je(e))};class xt{constructor(e){this.listenedKey=e,this.eventKeys.push(v(document,"keydown",this.handleKeyDown.bind(this)),v(document,"keyup",this.handleKeyUp.bind(this)))}eventKeys=[];keyDown=!1;keyDownCallback;keyUpCallback;destroy(){pt(this.eventKeys)}isKeyDown(){return this.keyDown}setOnKeyDown(e){this.keyDownCallback=e}setOnKeyUp(e){this.keyUpCallback=e}handleKeyDown(e){e instanceof KeyboardEvent&&e.key===this.listenedKey&&(this.keyDown=!0,this.keyDownCallback&&this.keyDownCallback())}handleKeyUp(e){e instanceof KeyboardEvent&&e.key===this.listenedKey&&(this.keyDown=!1,this.keyUpCallback&&this.keyUpCallback())}}const Ct=(l,e)=>{l.get("draw-style-set")||(l.setStyle(e),l.set("draw-style-set",!0))},St=new re,E=Qe.createEmptyMap(),H="layer1-id",Ft="background1-id",W="point-interaction-uid",oe="line-interaction-uid",Ie="modify-interaction-uid",Tt=new Ae({source:new be({features:new D([new O])})}),Et=new Ze({source:new et}),Se=l=>{document.querySelector("#console .text").textContent=l};E.setView(new tt({center:[0,0],zoom:2}));E.setTarget("map");let G=new Le(E);G.addLayer(Tt,H);const wt=new nt(E);wt.addLayer(Et,Ft);const K=new Ge(E,"modifyGroup"),P=new Ge(E,"drawGroup");let Fe,Te,Ee,we,ve,j;const vt=[],Pt=()=>{G=new Le(E);const l=G?.getLayer(H),e=l?.getSource();if(!l||!e||!E){console.error("No layer source or no map to draw in.");return}Ct(l,N),j=new xt("Delete"),Fe=new _e({source:e,type:"Point",condition:()=>!j?.isKeyDown(),style:N}),P.add(W,Fe),Te=new _e({source:e,type:"LineString",condition:()=>!j?.isKeyDown(),style:N}),P.add(oe,Te),Ee=new ut({source:e,style:N,deleteCondition:yt(st([at,mt(()=>j.isKeyDown())]),Mt.bind(void 0))}),K.add(Ie,Ee),we=new ht({layers:[l],condition:it}),K.add("translate",we),ve=new _t({source:e}),K.add("snap",ve),vt.push(P.find(W)?.on("drawend",()=>{Se("Point added.")}),P.find(oe)?.on("drawend",()=>{Se("Line added.")}))},N=l=>{const e=l?.getGeometry(),t=e?.getType();if(["MultiPoint","Point"].includes(`${t}`)&&e){const n=e.getCoordinates()[0]??0,s=Math.round(Math.abs(n)/(20037508/2)*255);return new re({image:new rt({radius:8,fill:new ot({color:`rgba(${s}, 0, 0, 0.7)`}),stroke:new ge({color:`rgba(${s}, 0, 0, 0.7)`})})})}else return["LineString","MultiLineString"].includes(`${t}`)&&e?new re({stroke:new ge({color:"rgba(200, 150, 0, 0.8)",width:4})}):St},Mt=l=>{setTimeout(()=>Dt(l),20)},Dt=l=>{l.map.forEachFeatureAtPixel(l.pixel,e=>{if(!G||e instanceof ct)return;const t=e.getGeometry();if(!t||t.getType()==="LineString"&&t.getCoordinates().length>2)return;if((G.getFeaturesCollection(H)?.getArray()||[]).includes(e)){G.removeFeatures(H,[e]);const s=K.find(Ie);s?.setActive(!1),s?.setActive(!0)}})};Pt();P.setActive(!0,W);const At=document.getElementById("type");At.addEventListener("change",l=>{l.target.value==="point"?P.setActive(!0,W):P.setActive(!0,oe)});
