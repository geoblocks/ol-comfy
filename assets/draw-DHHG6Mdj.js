var lt=Object.defineProperty;var dt=(h,e,t)=>e in h?lt(h,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):h[e]=t;var v=(h,e,t)=>dt(h,typeof e!="symbol"?e+"":e,t);import{S as $,c as ct,i as He,f as ut,d as gt,r as ft,G as _t,u as se,l as L,E as K,a as H,b as mt,e as yt,g as pt,h as G,m as Ct,j as xt,k as wt,n as We,o as Ft,p as Pt,q as ze,s as Tt,t as Et,v as St,w as vt,x as Dt,y as kt,z as Ie,P as R,A as Mt,B as It,C as Lt,D as At,F as Gt,H as Re,I as Rt,J as bt,K as Ot,L as Vt,M as ie,N as Nt,O as jt,Q as Ut,R as ue,T as Ze,U as ne,V as y,W as b,X as Bt,Y as re,Z as Kt,_ as Je,$ as F,a0 as qt,a1 as x,a2 as oe,a3 as be,a4 as ve,a5 as Qe,a6 as ge,a7 as Xt,a8 as Yt,a9 as $t,aa as Ht,ab as Wt,ac as j,ad as ae,ae as me,af as S,ag as T,ah as q,ai as zt,aj as et,ak as tt,al as Zt,am as st,an as Jt,ao as Qt,ap as Oe,aq as es,ar as ts,as as ss,at as is,au as ns,av as rs,aw as os,ax as as,ay as hs,az as ls,aA as Ve,aB as ds,aC as Ne,aD as cs,aE as us}from"./background-layer-group-BHHsv2n-.js";import{l as gs,i as it,a as nt,b as fs,c as _s,V as Le,d as Ae,F as k,R as rt,e as he,O as ot,f as ms}from"./overlay-layer-group-C1W9dQjl.js";class fe extends ${constructor(e,t,s){super(),s!==void 0&&t===void 0?this.setFlatCoordinates(s,e):(t=t||0,this.setCenterAndRadius(e,t,s))}clone(){const e=new fe(this.flatCoordinates.slice(),void 0,this.layout);return e.applyProperties(this),e}closestPointXY(e,t,s,i){const n=this.flatCoordinates,r=e-n[0],o=t-n[1],a=r*r+o*o;if(a<i){if(a===0)for(let l=0;l<this.stride;++l)s[l]=n[l];else{const l=this.getRadius()/Math.sqrt(a);s[0]=n[0]+l*r,s[1]=n[1]+l*o;for(let d=2;d<this.stride;++d)s[d]=n[d]}return s.length=this.stride,a}return i}containsXY(e,t){const s=this.flatCoordinates,i=e-s[0],n=t-s[1];return i*i+n*n<=this.getRadiusSquared_()}getCenter(){return this.flatCoordinates.slice(0,this.stride)}computeExtent(e){const t=this.flatCoordinates,s=t[this.stride]-t[0];return ct(t[0]-s,t[1]-s,t[0]+s,t[1]+s,e)}getRadius(){return Math.sqrt(this.getRadiusSquared_())}getRadiusSquared_(){const e=this.flatCoordinates[this.stride]-this.flatCoordinates[0],t=this.flatCoordinates[this.stride+1]-this.flatCoordinates[1];return e*e+t*t}getType(){return"Circle"}intersectsExtent(e){const t=this.getExtent();if(He(e,t)){const s=this.getCenter();return e[0]<=s[0]&&e[2]>=s[0]||e[1]<=s[1]&&e[3]>=s[1]?!0:ut(e,this.intersectsCoordinate.bind(this))}return!1}setCenter(e){const t=this.stride,s=this.flatCoordinates[t]-this.flatCoordinates[0],i=e.slice();i[t]=i[0]+s;for(let n=1;n<t;++n)i[t+n]=e[n];this.setFlatCoordinates(this.layout,i),this.changed()}setCenterAndRadius(e,t,s){this.setLayout(s,e,0),this.flatCoordinates||(this.flatCoordinates=[]);const i=this.flatCoordinates;let n=gt(i,0,e,this.stride);i[n++]=i[0]+t;for(let r=1,o=this.stride;r<o;++r)i[n++]=i[r];i.length=n,this.changed()}getCoordinates(){return null}setCoordinates(e,t){}setRadius(e){this.flatCoordinates[this.stride]=this.flatCoordinates[0]+e,this.changed()}rotate(e,t){const s=this.getCenter(),i=this.getStride();this.setCenter(ft(s,0,s.length,i,e,t,s)),this.changed()}}fe.prototype.transform;class le extends _t{constructor(e){super(),this.geometries_=e,this.changeEventsKeys_=[],this.listenGeometriesChange_()}unlistenGeometriesChange_(){this.changeEventsKeys_.forEach(se),this.changeEventsKeys_.length=0}listenGeometriesChange_(){const e=this.geometries_;for(let t=0,s=e.length;t<s;++t)this.changeEventsKeys_.push(L(e[t],K.CHANGE,this.changed,this))}clone(){const e=new le(ye(this.geometries_));return e.applyProperties(this),e}closestPointXY(e,t,s,i){if(i<H(this.getExtent(),e,t))return i;const n=this.geometries_;for(let r=0,o=n.length;r<o;++r)i=n[r].closestPointXY(e,t,s,i);return i}containsXY(e,t){const s=this.geometries_;for(let i=0,n=s.length;i<n;++i)if(s[i].containsXY(e,t))return!0;return!1}computeExtent(e){mt(e);const t=this.geometries_;for(let s=0,i=t.length;s<i;++s)yt(e,t[s].getExtent());return e}getGeometries(){return ye(this.geometries_)}getGeometriesArray(){return this.geometries_}getGeometriesArrayRecursive(){let e=[];const t=this.geometries_;for(let s=0,i=t.length;s<i;++s)t[s].getType()===this.getType()?e=e.concat(t[s].getGeometriesArrayRecursive()):e.push(t[s]);return e}getSimplifiedGeometry(e){if(this.simplifiedGeometryRevision!==this.getRevision()&&(this.simplifiedGeometryMaxMinSquaredTolerance=0,this.simplifiedGeometryRevision=this.getRevision()),e<0||this.simplifiedGeometryMaxMinSquaredTolerance!==0&&e<this.simplifiedGeometryMaxMinSquaredTolerance)return this;const t=[],s=this.geometries_;let i=!1;for(let n=0,r=s.length;n<r;++n){const o=s[n],a=o.getSimplifiedGeometry(e);t.push(a),a!==o&&(i=!0)}return i?new le(t):(this.simplifiedGeometryMaxMinSquaredTolerance=e,this)}getType(){return"GeometryCollection"}intersectsExtent(e){const t=this.geometries_;for(let s=0,i=t.length;s<i;++s)if(t[s].intersectsExtent(e))return!0;return!1}isEmpty(){return this.geometries_.length===0}rotate(e,t){const s=this.geometries_;for(let i=0,n=s.length;i<n;++i)s[i].rotate(e,t);this.changed()}scale(e,t,s){s||(s=pt(this.getExtent()));const i=this.geometries_;for(let n=0,r=i.length;n<r;++n)i[n].scale(e,t,s);this.changed()}setGeometries(e){this.setGeometriesArray(ye(e))}setGeometriesArray(e){this.unlistenGeometriesChange_(),this.geometries_=e,this.listenGeometriesChange_(),this.changed()}applyTransform(e){const t=this.geometries_;for(let s=0,i=t.length;s<i;++s)t[s].applyTransform(e);this.changed()}translate(e,t){const s=this.geometries_;for(let i=0,n=s.length;i<n;++i)s[i].translate(e,t);this.changed()}disposeInternal(){this.unlistenGeometriesChange_(),super.disposeInternal()}}function ye(h){return h.map(e=>e.clone())}class M extends ${constructor(e,t){super(),this.flatMidpoint_=null,this.flatMidpointRevision_=-1,this.maxDelta_=-1,this.maxDeltaRevision_=-1,t!==void 0&&!Array.isArray(e[0])?this.setFlatCoordinates(t,e):this.setCoordinates(e,t)}appendCoordinate(e){G(this.flatCoordinates,e),this.changed()}clone(){const e=new M(this.flatCoordinates.slice(),this.layout);return e.applyProperties(this),e}closestPointXY(e,t,s,i){return i<H(this.getExtent(),e,t)?i:(this.maxDeltaRevision_!=this.getRevision()&&(this.maxDelta_=Math.sqrt(Ct(this.flatCoordinates,0,this.flatCoordinates.length,this.stride,0)),this.maxDeltaRevision_=this.getRevision()),xt(this.flatCoordinates,0,this.flatCoordinates.length,this.stride,this.maxDelta_,!1,e,t,s,i))}forEachSegment(e){return wt(this.flatCoordinates,0,this.flatCoordinates.length,this.stride,e)}getCoordinateAtM(e,t){return this.layout!="XYM"&&this.layout!="XYZM"?null:(t=t!==void 0?t:!1,gs(this.flatCoordinates,0,this.flatCoordinates.length,this.stride,e,t))}getCoordinates(){return We(this.flatCoordinates,0,this.flatCoordinates.length,this.stride)}getCoordinateAt(e,t){return it(this.flatCoordinates,0,this.flatCoordinates.length,this.stride,e,t,this.stride)}getLength(){return nt(this.flatCoordinates,0,this.flatCoordinates.length,this.stride)}getFlatMidpoint(){return this.flatMidpointRevision_!=this.getRevision()&&(this.flatMidpoint_=this.getCoordinateAt(.5,this.flatMidpoint_??void 0),this.flatMidpointRevision_=this.getRevision()),this.flatMidpoint_}getSimplifiedGeometryInternal(e){const t=[];return t.length=Ft(this.flatCoordinates,0,this.flatCoordinates.length,this.stride,e,t,0),new M(t,"XY")}getType(){return"LineString"}intersectsExtent(e){return Pt(this.flatCoordinates,0,this.flatCoordinates.length,this.stride,e,this.getExtent())}setCoordinates(e,t){this.setLayout(t,e,1),this.flatCoordinates||(this.flatCoordinates=[]),this.flatCoordinates.length=ze(this.flatCoordinates,0,e,this.stride),this.changed()}}class X extends ${constructor(e,t,s){if(super(),this.ends_=[],this.maxDelta_=-1,this.maxDeltaRevision_=-1,Array.isArray(e[0]))this.setCoordinates(e,t);else if(t!==void 0&&s)this.setFlatCoordinates(t,e),this.ends_=s;else{const i=e,n=[],r=[];for(let a=0,l=i.length;a<l;++a){const d=i[a];G(n,d.getFlatCoordinates()),r.push(n.length)}const o=i.length===0?this.getLayout():i[0].getLayout();this.setFlatCoordinates(o,n),this.ends_=r}}appendLineString(e){G(this.flatCoordinates,e.getFlatCoordinates().slice()),this.ends_.push(this.flatCoordinates.length),this.changed()}clone(){const e=new X(this.flatCoordinates.slice(),this.layout,this.ends_.slice());return e.applyProperties(this),e}closestPointXY(e,t,s,i){return i<H(this.getExtent(),e,t)?i:(this.maxDeltaRevision_!=this.getRevision()&&(this.maxDelta_=Math.sqrt(Tt(this.flatCoordinates,0,this.ends_,this.stride,0)),this.maxDeltaRevision_=this.getRevision()),Et(this.flatCoordinates,0,this.ends_,this.stride,this.maxDelta_,!1,e,t,s,i))}getCoordinateAtM(e,t,s){return this.layout!="XYM"&&this.layout!="XYZM"||this.flatCoordinates.length===0?null:(t=t!==void 0?t:!1,s=s!==void 0?s:!1,fs(this.flatCoordinates,0,this.ends_,this.stride,e,t,s))}getCoordinates(){return St(this.flatCoordinates,0,this.ends_,this.stride)}getEnds(){return this.ends_}getLineString(e){return e<0||this.ends_.length<=e?null:new M(this.flatCoordinates.slice(e===0?0:this.ends_[e-1],this.ends_[e]),this.layout)}getLineStrings(){const e=this.flatCoordinates,t=this.ends_,s=this.layout,i=[];let n=0;for(let r=0,o=t.length;r<o;++r){const a=t[r],l=new M(e.slice(n,a),s);i.push(l),n=a}return i}getLength(){const e=this.ends_;let t=0,s=0;for(let i=0,n=e.length;i<n;++i)s+=nt(this.flatCoordinates,t,e[i],this.stride),t=e[i];return s}getFlatMidpoints(){const e=[],t=this.flatCoordinates;let s=0;const i=this.ends_,n=this.stride;for(let r=0,o=i.length;r<o;++r){const a=i[r],l=it(t,s,a,n,.5);G(e,l),s=a}return e}getSimplifiedGeometryInternal(e){const t=[],s=[];return t.length=vt(this.flatCoordinates,0,this.ends_,this.stride,e,t,0,s),new X(t,"XY",s)}getType(){return"MultiLineString"}intersectsExtent(e){return Dt(this.flatCoordinates,0,this.ends_,this.stride,e)}setCoordinates(e,t){this.setLayout(t,e,2),this.flatCoordinates||(this.flatCoordinates=[]);const s=kt(this.flatCoordinates,0,e,this.stride,this.ends_);this.flatCoordinates.length=s.length===0?0:s[s.length-1],this.changed()}}class _e extends ${constructor(e,t){super(),t&&!Array.isArray(e[0])?this.setFlatCoordinates(t,e):this.setCoordinates(e,t)}appendPoint(e){G(this.flatCoordinates,e.getFlatCoordinates()),this.changed()}clone(){const e=new _e(this.flatCoordinates.slice(),this.layout);return e.applyProperties(this),e}closestPointXY(e,t,s,i){if(i<H(this.getExtent(),e,t))return i;const n=this.flatCoordinates,r=this.stride;for(let o=0,a=n.length;o<a;o+=r){const l=Ie(e,t,n[o],n[o+1]);if(l<i){i=l;for(let d=0;d<r;++d)s[d]=n[o+d];s.length=r}}return i}getCoordinates(){return We(this.flatCoordinates,0,this.flatCoordinates.length,this.stride)}getPoint(e){const t=this.flatCoordinates.length/this.stride;return e<0||t<=e?null:new R(this.flatCoordinates.slice(e*this.stride,(e+1)*this.stride),this.layout)}getPoints(){const e=this.flatCoordinates,t=this.layout,s=this.stride,i=[];for(let n=0,r=e.length;n<r;n+=s){const o=new R(e.slice(n,n+s),t);i.push(o)}return i}getType(){return"MultiPoint"}intersectsExtent(e){const t=this.flatCoordinates,s=this.stride;for(let i=0,n=t.length;i<n;i+=s){const r=t[i],o=t[i+1];if(Mt(e,r,o))return!0}return!1}setCoordinates(e,t){this.setLayout(t,e,1),this.flatCoordinates||(this.flatCoordinates=[]),this.flatCoordinates.length=ze(this.flatCoordinates,0,e,this.stride),this.changed()}}class Y extends ${constructor(e,t,s){if(super(),this.endss_=[],this.flatInteriorPointsRevision_=-1,this.flatInteriorPoints_=null,this.maxDelta_=-1,this.maxDeltaRevision_=-1,this.orientedRevision_=-1,this.orientedFlatCoordinates_=null,!s&&!Array.isArray(e[0])){const i=e,n=[],r=[];for(let o=0,a=i.length;o<a;++o){const l=i[o],d=n.length,g=l.getEnds();for(let c=0,u=g.length;c<u;++c)g[c]+=d;G(n,l.getFlatCoordinates()),r.push(g)}t=i.length===0?this.getLayout():i[0].getLayout(),e=n,s=r}t!==void 0&&s?(this.setFlatCoordinates(t,e),this.endss_=s):this.setCoordinates(e,t)}appendPolygon(e){let t;if(!this.flatCoordinates)this.flatCoordinates=e.getFlatCoordinates().slice(),t=e.getEnds().slice(),this.endss_.push();else{const s=this.flatCoordinates.length;G(this.flatCoordinates,e.getFlatCoordinates()),t=e.getEnds().slice();for(let i=0,n=t.length;i<n;++i)t[i]+=s}this.endss_.push(t),this.changed()}clone(){const e=this.endss_.length,t=new Array(e);for(let i=0;i<e;++i)t[i]=this.endss_[i].slice();const s=new Y(this.flatCoordinates.slice(),this.layout,t);return s.applyProperties(this),s}closestPointXY(e,t,s,i){return i<H(this.getExtent(),e,t)?i:(this.maxDeltaRevision_!=this.getRevision()&&(this.maxDelta_=Math.sqrt(It(this.flatCoordinates,0,this.endss_,this.stride,0)),this.maxDeltaRevision_=this.getRevision()),Lt(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride,this.maxDelta_,!0,e,t,s,i))}containsXY(e,t){return At(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride,e,t)}getArea(){return Gt(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride)}getCoordinates(e){let t;return e!==void 0?(t=this.getOrientedFlatCoordinates().slice(),Re(t,0,this.endss_,this.stride,e)):t=this.flatCoordinates,Rt(t,0,this.endss_,this.stride)}getEndss(){return this.endss_}getFlatInteriorPoints(){if(this.flatInteriorPointsRevision_!=this.getRevision()){const e=_s(this.flatCoordinates,0,this.endss_,this.stride);this.flatInteriorPoints_=bt(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride,e),this.flatInteriorPointsRevision_=this.getRevision()}return this.flatInteriorPoints_}getInteriorPoints(){return new _e(this.getFlatInteriorPoints().slice(),"XYM")}getOrientedFlatCoordinates(){if(this.orientedRevision_!=this.getRevision()){const e=this.flatCoordinates;Ot(e,0,this.endss_,this.stride)?this.orientedFlatCoordinates_=e:(this.orientedFlatCoordinates_=e.slice(),this.orientedFlatCoordinates_.length=Re(this.orientedFlatCoordinates_,0,this.endss_,this.stride)),this.orientedRevision_=this.getRevision()}return this.orientedFlatCoordinates_}getSimplifiedGeometryInternal(e){const t=[],s=[];return t.length=Vt(this.flatCoordinates,0,this.endss_,this.stride,Math.sqrt(e),t,0,s),new Y(t,"XY",s)}getPolygon(e){if(e<0||this.endss_.length<=e)return null;let t;if(e===0)t=0;else{const n=this.endss_[e-1];t=n[n.length-1]}const s=this.endss_[e].slice(),i=s[s.length-1];if(t!==0)for(let n=0,r=s.length;n<r;++n)s[n]-=t;return new ie(this.flatCoordinates.slice(t,i),this.layout,s)}getPolygons(){const e=this.layout,t=this.flatCoordinates,s=this.endss_,i=[];let n=0;for(let r=0,o=s.length;r<o;++r){const a=s[r].slice(),l=a[a.length-1];if(n!==0)for(let g=0,c=a.length;g<c;++g)a[g]-=n;const d=new ie(t.slice(n,l),e,a);i.push(d),n=l}return i}getType(){return"MultiPolygon"}intersectsExtent(e){return Nt(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride,e)}setCoordinates(e,t){this.setLayout(t,e,3),this.flatCoordinates||(this.flatCoordinates=[]);const s=jt(this.flatCoordinates,0,e,this.stride,this.endss_);if(s.length===0)this.flatCoordinates.length=0;else{const i=s[s.length-1];this.flatCoordinates.length=i.length===0?0:i[i.length-1]}this.changed()}}const ys=h=>e=>h(),ps=(h,e)=>t=>h(t)?(e(t),!0):!1,Cs=h=>{h.forEach(e=>Ut(e))};class xs{constructor(e){v(this,"eventKeys",[]);v(this,"keyDown",!1);v(this,"keyDownCallback");v(this,"keyUpCallback");this.listenedKey=e,this.eventKeys.push(L(document,"keydown",this.handleKeyDown.bind(this))),this.eventKeys.push(L(document,"keyup",this.handleKeyUp.bind(this)))}destroy(){Cs(this.eventKeys)}isKeyDown(){return this.keyDown}setOnKeyDown(e){this.keyDownCallback=e}setOnKeyUp(e){this.keyUpCallback=e}handleKeyDown(e){e instanceof KeyboardEvent&&e.key===this.listenedKey&&(this.keyDown=!0,this.keyDownCallback&&this.keyDownCallback())}handleKeyUp(e){e instanceof KeyboardEvent&&e.key===this.listenedKey&&(this.keyDown=!1,this.keyUpCallback&&this.keyUpCallback())}}const ws=(h,e)=>{h.get("draw-style-set")||(h.setStyle(e),h.set("draw-style-set",!0))},W={DRAWSTART:"drawstart",DRAWEND:"drawend",DRAWABORT:"drawabort"};class z extends ge{constructor(e,t){super(e),this.feature=t}}function Fs(h,e){const t=[];for(let s=0;s<e.length;++s){const n=e[s].getGeometry();at(h,n,t)}return t}function Z(h,e){return Ie(h[0],h[1],e[0],e[1])}function V(h,e){const t=h.length;return e<0?h[e+t]:e>=t?h[e-t]:h[e]}function J(h,e,t){let s,i;e<t?(s=e,i=t):(s=t,i=e);const n=Math.ceil(s),r=Math.floor(i);if(n>r){const a=N(h,s),l=N(h,i);return Z(a,l)}let o=0;if(s<n){const a=N(h,s),l=V(h,n);o+=Z(a,l)}if(r<i){const a=V(h,r),l=N(h,i);o+=Z(a,l)}for(let a=n;a<r-1;++a){const l=V(h,a),d=V(h,a+1);o+=Z(l,d)}return o}function at(h,e,t){if(e instanceof M){Q(h,e.getCoordinates(),!1,t);return}if(e instanceof X){const s=e.getCoordinates();for(let i=0,n=s.length;i<n;++i)Q(h,s[i],!1,t);return}if(e instanceof ie){const s=e.getCoordinates();for(let i=0,n=s.length;i<n;++i)Q(h,s[i],!0,t);return}if(e instanceof Y){const s=e.getCoordinates();for(let i=0,n=s.length;i<n;++i){const r=s[i];for(let o=0,a=r.length;o<a;++o)Q(h,r[o],!0,t)}return}if(e instanceof le){const s=e.getGeometries();for(let i=0;i<s.length;++i)at(h,s[i],t);return}}const pe={index:-1,endIndex:NaN};function Ps(h,e,t,s){const i=h[0],n=h[1];let r=1/0,o=-1,a=NaN;for(let g=0;g<e.targets.length;++g){const c=e.targets[g],u=c.coordinates;let f=1/0,_;for(let m=0;m<u.length-1;++m){const p=u[m],C=u[m+1],w=ht(i,n,p,C);w.squaredDistance<f&&(f=w.squaredDistance,_=m+w.along)}f<r&&(r=f,c.ring&&e.targetIndex===g&&(c.endIndex>c.startIndex?_<c.startIndex&&(_+=u.length):c.endIndex<c.startIndex&&_>c.startIndex&&(_-=u.length)),a=_,o=g)}const l=e.targets[o];let d=l.ring;if(e.targetIndex===o&&d){const g=N(l.coordinates,a),c=t.getPixelFromCoordinate(g);oe(c,e.startPx)>s&&(d=!1)}if(d){const g=l.coordinates,c=g.length,u=l.startIndex,f=a;if(u<f){const _=J(g,u,f);J(g,u,f-c)<_&&(a-=c)}else{const _=J(g,u,f);J(g,u,f+c)<_&&(a+=c)}}return pe.index=o,pe.endIndex=a,pe}function Q(h,e,t,s){const i=h[0],n=h[1];for(let r=0,o=e.length-1;r<o;++r){const a=e[r],l=e[r+1],d=ht(i,n,a,l);if(d.squaredDistance===0){const g=r+d.along;s.push({coordinates:e,ring:t,startIndex:g,endIndex:g});return}}}const Ce={along:0,squaredDistance:0};function ht(h,e,t,s){const i=t[0],n=t[1],r=s[0],o=s[1],a=r-i,l=o-n;let d=0,g=i,c=n;return(a!==0||l!==0)&&(d=Yt(((h-i)*a+(e-n)*l)/(a*a+l*l),0,1),g+=a*d,c+=l*d),Ce.along=d,Ce.squaredDistance=Xt(Ie(h,e,g,c),10),Ce}function N(h,e){const t=h.length;let s=Math.floor(e);const i=e-s;s>=t?s-=t:s<0&&(s+=t);let n=s+1;n>=t&&(n-=t);const r=h[s],o=r[0],a=r[1],l=h[n],d=l[0]-o,g=l[1]-a;return[o+d*i,a+g*i]}let Ts=class extends ue{constructor(e){const t=e;t.stopDown||(t.stopDown=Ze),super(t),this.on,this.once,this.un,this.shouldHandle_=!1,this.downPx_=null,this.downTimeout_,this.lastDragTime_,this.pointerType_,this.freehand_=!1,this.source_=e.source?e.source:null,this.features_=e.features?e.features:null,this.snapTolerance_=e.snapTolerance?e.snapTolerance:12,this.type_=e.type,this.mode_=Ss(this.type_),this.stopClick_=!!e.stopClick,this.minPoints_=e.minPoints?e.minPoints:this.mode_==="Polygon"?3:2,this.maxPoints_=this.mode_==="Circle"?2:e.maxPoints?e.maxPoints:1/0,this.finishCondition_=e.finishCondition?e.finishCondition:ne,this.geometryLayout_=e.geometryLayout?e.geometryLayout:"XY";let s=e.geometryFunction;if(!s){const i=this.mode_;if(i==="Circle")s=(n,r,o)=>{const a=r||new fe([NaN,NaN]),l=y(n[0]),d=b(l,y(n[n.length-1]));return a.setCenterAndRadius(l,Math.sqrt(d),this.geometryLayout_),a};else{let n;i==="Point"?n=R:i==="LineString"?n=M:i==="Polygon"&&(n=ie),s=(r,o,a)=>(o?i==="Polygon"?r[0].length?o.setCoordinates([r[0].concat([r[0][0]])],this.geometryLayout_):o.setCoordinates([],this.geometryLayout_):o.setCoordinates(r,this.geometryLayout_):o=new n(r,this.geometryLayout_),o)}}this.geometryFunction_=s,this.dragVertexDelay_=e.dragVertexDelay!==void 0?e.dragVertexDelay:500,this.finishCoordinate_=null,this.sketchFeature_=null,this.sketchPoint_=null,this.sketchCoords_=null,this.sketchLine_=null,this.sketchLineCoords_=null,this.squaredClickTolerance_=e.clickTolerance?e.clickTolerance*e.clickTolerance:36,this.overlay_=new Le({source:new Ae({useSpatialIndex:!1,wrapX:e.wrapX?e.wrapX:!1}),style:e.style?e.style:Es(),updateWhileInteracting:!0}),this.geometryName_=e.geometryName,this.condition_=e.condition?e.condition:Bt,this.freehandCondition_,e.freehand?this.freehandCondition_=re:this.freehandCondition_=e.freehandCondition?e.freehandCondition:Kt,this.traceCondition_,this.setTrace(e.trace||!1),this.traceState_={active:!1},this.traceSource_=e.traceSource||e.source||null,this.addChangeListener(Je.ACTIVE,this.updateState_)}setTrace(e){let t;e?e===!0?t=re:t=e:t=ve,this.traceCondition_=t}setMap(e){super.setMap(e),this.updateState_()}getOverlay(){return this.overlay_}handleEvent(e){e.originalEvent.type===K.CONTEXTMENU&&e.originalEvent.preventDefault(),this.freehand_=this.mode_!=="Point"&&this.freehandCondition_(e);let t=e.type===F.POINTERMOVE,s=!0;return!this.freehand_&&this.lastDragTime_&&e.type===F.POINTERDRAG&&(Date.now()-this.lastDragTime_>=this.dragVertexDelay_?(this.downPx_=e.pixel,this.shouldHandle_=!this.freehand_,t=!0):this.lastDragTime_=void 0,this.shouldHandle_&&this.downTimeout_!==void 0&&(clearTimeout(this.downTimeout_),this.downTimeout_=void 0)),this.freehand_&&e.type===F.POINTERDRAG&&this.sketchFeature_!==null?(this.addToDrawing_(e.coordinate),s=!1):this.freehand_&&e.type===F.POINTERDOWN?s=!1:t&&this.getPointerCount()<2?(s=e.type===F.POINTERMOVE,s&&this.freehand_?(this.handlePointerMove_(e),this.shouldHandle_&&e.originalEvent.preventDefault()):(e.originalEvent.pointerType==="mouse"||e.type===F.POINTERDRAG&&this.downTimeout_===void 0)&&this.handlePointerMove_(e)):e.type===F.DBLCLICK&&(s=!1),super.handleEvent(e)&&s}handleDownEvent(e){return this.shouldHandle_=!this.freehand_,this.freehand_?(this.downPx_=e.pixel,this.finishCoordinate_||this.startDrawing_(e.coordinate),!0):this.condition_(e)?(this.lastDragTime_=Date.now(),this.downTimeout_=setTimeout(()=>{this.handlePointerMove_(new qt(F.POINTERMOVE,e.map,e.originalEvent,!1,e.frameState))},this.dragVertexDelay_),this.downPx_=e.pixel,!0):(this.lastDragTime_=void 0,!1)}deactivateTrace_(){this.traceState_={active:!1}}toggleTraceState_(e){if(!this.traceSource_||!this.traceCondition_(e))return;if(this.traceState_.active){this.deactivateTrace_();return}const t=this.getMap(),s=t.getCoordinateFromPixel([e.pixel[0]-this.snapTolerance_,e.pixel[1]+this.snapTolerance_]),i=t.getCoordinateFromPixel([e.pixel[0]+this.snapTolerance_,e.pixel[1]-this.snapTolerance_]),n=x([s,i]),r=this.traceSource_.getFeaturesInExtent(n);if(r.length===0)return;const o=Fs(e.coordinate,r);o.length&&(this.traceState_={active:!0,startPx:e.pixel.slice(),targets:o,targetIndex:-1})}addOrRemoveTracedCoordinates_(e,t){const s=e.startIndex<=e.endIndex,i=e.startIndex<=t;s===i?s&&t>e.endIndex||!s&&t<e.endIndex?this.addTracedCoordinates_(e,e.endIndex,t):(s&&t<e.endIndex||!s&&t>e.endIndex)&&this.removeTracedCoordinates_(t,e.endIndex):(this.removeTracedCoordinates_(e.startIndex,e.endIndex),this.addTracedCoordinates_(e,e.startIndex,t))}removeTracedCoordinates_(e,t){if(e===t)return;let s=0;if(e<t){const i=Math.ceil(e);let n=Math.floor(t);n===t&&(n-=1),s=n-i+1}else{const i=Math.floor(e);let n=Math.ceil(t);n===t&&(n+=1),s=i-n+1}s>0&&this.removeLastPoints_(s)}addTracedCoordinates_(e,t,s){if(t===s)return;const i=[];if(t<s){const n=Math.ceil(t);let r=Math.floor(s);r===s&&(r-=1);for(let o=n;o<=r;++o)i.push(V(e.coordinates,o))}else{const n=Math.floor(t);let r=Math.ceil(s);r===s&&(r+=1);for(let o=n;o>=r;--o)i.push(V(e.coordinates,o))}i.length&&this.appendCoordinates(i)}updateTrace_(e){const t=this.traceState_;if(!t.active||t.targetIndex===-1&&oe(t.startPx,e.pixel)<this.snapTolerance_)return;const s=Ps(e.coordinate,t,this.getMap(),this.snapTolerance_);if(t.targetIndex!==s.index){if(t.targetIndex!==-1){const a=t.targets[t.targetIndex];this.removeTracedCoordinates_(a.startIndex,a.endIndex)}const o=t.targets[s.index];this.addTracedCoordinates_(o,o.startIndex,s.endIndex)}else{const o=t.targets[t.targetIndex];this.addOrRemoveTracedCoordinates_(o,s.endIndex)}t.targetIndex=s.index;const i=t.targets[t.targetIndex];i.endIndex=s.endIndex;const n=N(i.coordinates,i.endIndex),r=this.getMap().getPixelFromCoordinate(n);e.coordinate=n,e.pixel=[Math.round(r[0]),Math.round(r[1])]}handleUpEvent(e){let t=!0;if(this.getPointerCount()===0){this.downTimeout_&&(clearTimeout(this.downTimeout_),this.downTimeout_=void 0),this.handlePointerMove_(e);const s=this.traceState_.active;if(this.toggleTraceState_(e),this.shouldHandle_){const i=!this.finishCoordinate_;i&&this.startDrawing_(e.coordinate),!i&&this.freehand_?this.finishDrawing():!this.freehand_&&(!i||this.mode_==="Point")&&(this.atFinish_(e.pixel,s)?this.finishCondition_(e)&&this.finishDrawing():this.addToDrawing_(e.coordinate)),t=!1}else this.freehand_&&this.abortDrawing()}return!t&&this.stopClick_&&e.preventDefault(),t}handlePointerMove_(e){if(this.pointerType_=e.originalEvent.pointerType,this.downPx_&&(!this.freehand_&&this.shouldHandle_||this.freehand_&&!this.shouldHandle_)){const t=this.downPx_,s=e.pixel,i=t[0]-s[0],n=t[1]-s[1],r=i*i+n*n;if(this.shouldHandle_=this.freehand_?r>this.squaredClickTolerance_:r<=this.squaredClickTolerance_,!this.shouldHandle_)return}if(!this.finishCoordinate_){this.createOrUpdateSketchPoint_(e.coordinate.slice());return}this.updateTrace_(e),this.modifyDrawing_(e.coordinate)}atFinish_(e,t){let s=!1;if(this.sketchFeature_){let i=!1,n=[this.finishCoordinate_];const r=this.mode_;if(r==="Point")s=!0;else if(r==="Circle")s=this.sketchCoords_.length===2;else if(r==="LineString")i=!t&&this.sketchCoords_.length>this.minPoints_;else if(r==="Polygon"){const o=this.sketchCoords_;i=o[0].length>this.minPoints_,n=[o[0][0],o[0][o[0].length-2]],t?n=[o[0][0]]:n=[o[0][0],o[0][o[0].length-2]]}if(i){const o=this.getMap();for(let a=0,l=n.length;a<l;a++){const d=n[a],g=o.getPixelFromCoordinate(d),c=e[0]-g[0],u=e[1]-g[1],f=this.freehand_?1:this.snapTolerance_;if(s=Math.sqrt(c*c+u*u)<=f,s){this.finishCoordinate_=d;break}}}}return s}createOrUpdateSketchPoint_(e){this.sketchPoint_?this.sketchPoint_.getGeometry().setCoordinates(e):(this.sketchPoint_=new k(new R(e)),this.updateSketchFeatures_())}createOrUpdateCustomSketchLine_(e){this.sketchLine_||(this.sketchLine_=new k);const t=e.getLinearRing(0);let s=this.sketchLine_.getGeometry();s?(s.setFlatCoordinates(t.getLayout(),t.getFlatCoordinates()),s.changed()):(s=new M(t.getFlatCoordinates(),t.getLayout()),this.sketchLine_.setGeometry(s))}startDrawing_(e){const t=this.getMap().getView().getProjection(),s=be(this.geometryLayout_);for(;e.length<s;)e.push(0);this.finishCoordinate_=e,this.mode_==="Point"?this.sketchCoords_=e.slice():this.mode_==="Polygon"?(this.sketchCoords_=[[e.slice(),e.slice()]],this.sketchLineCoords_=this.sketchCoords_[0]):this.sketchCoords_=[e.slice(),e.slice()],this.sketchLineCoords_&&(this.sketchLine_=new k(new M(this.sketchLineCoords_)));const i=this.geometryFunction_(this.sketchCoords_,void 0,t);this.sketchFeature_=new k,this.geometryName_&&this.sketchFeature_.setGeometryName(this.geometryName_),this.sketchFeature_.setGeometry(i),this.updateSketchFeatures_(),this.dispatchEvent(new z(W.DRAWSTART,this.sketchFeature_))}modifyDrawing_(e){const t=this.getMap(),s=this.sketchFeature_.getGeometry(),i=t.getView().getProjection(),n=be(this.geometryLayout_);let r,o;for(;e.length<n;)e.push(0);this.mode_==="Point"?o=this.sketchCoords_:this.mode_==="Polygon"?(r=this.sketchCoords_[0],o=r[r.length-1],this.atFinish_(t.getPixelFromCoordinate(e))&&(e=this.finishCoordinate_.slice())):(r=this.sketchCoords_,o=r[r.length-1]),o[0]=e[0],o[1]=e[1],this.geometryFunction_(this.sketchCoords_,s,i),this.sketchPoint_&&this.sketchPoint_.getGeometry().setCoordinates(e),s.getType()==="Polygon"&&this.mode_!=="Polygon"?this.createOrUpdateCustomSketchLine_(s):this.sketchLineCoords_&&this.sketchLine_.getGeometry().setCoordinates(this.sketchLineCoords_),this.updateSketchFeatures_()}addToDrawing_(e){const t=this.sketchFeature_.getGeometry(),s=this.getMap().getView().getProjection();let i,n;const r=this.mode_;return r==="LineString"||r==="Circle"?(this.finishCoordinate_=e.slice(),n=this.sketchCoords_,n.length>=this.maxPoints_&&(this.freehand_?n.pop():i=!0),n.push(e.slice()),this.geometryFunction_(n,t,s)):r==="Polygon"&&(n=this.sketchCoords_[0],n.length>=this.maxPoints_&&(this.freehand_?n.pop():i=!0),n.push(e.slice()),i&&(this.finishCoordinate_=n[0]),this.geometryFunction_(this.sketchCoords_,t,s)),this.createOrUpdateSketchPoint_(e.slice()),this.updateSketchFeatures_(),i?this.finishDrawing():this.sketchFeature_}removeLastPoints_(e){if(!this.sketchFeature_)return;const t=this.sketchFeature_.getGeometry(),s=this.getMap().getView().getProjection(),i=this.mode_;for(let n=0;n<e;++n){let r;if(i==="LineString"||i==="Circle"){if(r=this.sketchCoords_,r.splice(-2,1),r.length>=2){this.finishCoordinate_=r[r.length-2].slice();const o=this.finishCoordinate_.slice();r[r.length-1]=o,this.createOrUpdateSketchPoint_(o)}this.geometryFunction_(r,t,s),t.getType()==="Polygon"&&this.sketchLine_&&this.createOrUpdateCustomSketchLine_(t)}else if(i==="Polygon"){r=this.sketchCoords_[0],r.splice(-2,1);const o=this.sketchLine_.getGeometry();if(r.length>=2){const a=r[r.length-2].slice();r[r.length-1]=a,this.createOrUpdateSketchPoint_(a)}o.setCoordinates(r),this.geometryFunction_(this.sketchCoords_,t,s)}if(r.length===1){this.abortDrawing();break}}this.updateSketchFeatures_()}removeLastPoint(){this.removeLastPoints_(1)}finishDrawing(){const e=this.abortDrawing_();if(!e)return null;let t=this.sketchCoords_;const s=e.getGeometry(),i=this.getMap().getView().getProjection();return this.mode_==="LineString"?(t.pop(),this.geometryFunction_(t,s,i)):this.mode_==="Polygon"&&(t[0].pop(),this.geometryFunction_(t,s,i),t=s.getCoordinates()),this.type_==="MultiPoint"?e.setGeometry(new _e([t])):this.type_==="MultiLineString"?e.setGeometry(new X([t])):this.type_==="MultiPolygon"&&e.setGeometry(new Y([t])),this.dispatchEvent(new z(W.DRAWEND,e)),this.features_&&this.features_.push(e),this.source_&&this.source_.addFeature(e),e}abortDrawing_(){this.finishCoordinate_=null;const e=this.sketchFeature_;return this.sketchFeature_=null,this.sketchPoint_=null,this.sketchLine_=null,this.overlay_.getSource().clear(!0),this.deactivateTrace_(),e}abortDrawing(){const e=this.abortDrawing_();e&&this.dispatchEvent(new z(W.DRAWABORT,e))}appendCoordinates(e){const t=this.mode_,s=!this.sketchFeature_;s&&this.startDrawing_(e[0]);let i;if(t==="LineString"||t==="Circle")i=this.sketchCoords_;else if(t==="Polygon")i=this.sketchCoords_&&this.sketchCoords_.length?this.sketchCoords_[0]:[];else return;s&&i.shift(),i.pop();for(let r=0;r<e.length;r++)this.addToDrawing_(e[r]);const n=e[e.length-1];this.sketchFeature_=this.addToDrawing_(n),this.modifyDrawing_(n)}extend(e){const s=e.getGeometry();this.sketchFeature_=e,this.sketchCoords_=s.getCoordinates();const i=this.sketchCoords_[this.sketchCoords_.length-1];this.finishCoordinate_=i.slice(),this.sketchCoords_.push(i.slice()),this.sketchPoint_=new k(new R(i)),this.updateSketchFeatures_(),this.dispatchEvent(new z(W.DRAWSTART,this.sketchFeature_))}updateSketchFeatures_(){const e=[];this.sketchFeature_&&e.push(this.sketchFeature_),this.sketchLine_&&e.push(this.sketchLine_),this.sketchPoint_&&e.push(this.sketchPoint_);const t=this.overlay_.getSource();t.clear(!0),t.addFeatures(e)}updateState_(){const e=this.getMap(),t=this.getActive();(!e||!t)&&this.abortDrawing(),this.overlay_.setMap(t?e:null)}};function Es(){const h=Qe();return function(e,t){return h[e.getGeometry().getType()]}}function Ss(h){switch(h){case"Point":case"MultiPoint":return"Point";case"LineString":case"MultiLineString":return"LineString";case"Polygon":case"MultiPolygon":return"Polygon";case"Circle":return"Circle";default:throw new Error("Invalid type: "+h)}}const je="olcInteractionDrawUid",vs="olcInteractionDrawUid",Ue="olcInteractionDrawGroup",Ds="olcStandardDraw";class ks{constructor(e,t){v(this,"interaction");this.map=e;const s=this.getDrawInteraction(t);s&&(this.interaction=s)}destroy(){this.map.removeInteraction(this.interaction)}getFullUid(e){return`${vs}-${e}`}getInteraction(){return this.interaction}setActive(e){e?this.use(this.interaction):this.interaction.setActive(!1)}registerInteraction(e,t){e.set(Ue,Ds),e.set(je,this.getFullUid(t)),e.setActive(!1),this.map.addInteraction(e)}use(e){this.deactivateAll(),e.setActive(!0)}deactivateAll(){this.getDrawInteractions().forEach(e=>e.setActive(!1))}getDrawInteraction(e){return this.map.getInteractions().getArray().find(t=>t.get(je)===this.getFullUid(e))}getDrawInteractions(){return this.map.getInteractions().getArray().filter(e=>!!e.get(Ue))}}class ee extends ks{constructor(e,t,s){super(e,s),this.interaction||this.createInteraction(s,t)}createInteraction(e,t){this.interaction=new Ts(t),this.registerInteraction(this.interaction,e)}static getDefaultPolygonOptions(e){return{freehandCondition:ve,source:e,type:"Polygon"}}static getDefaultCircleOptions(e){return{source:e,type:"Circle"}}static getDefaultLineOptions(e){return{freehandCondition:ve,source:e,type:"LineString"}}static getDefaultPointOptions(e){return{source:e,type:"Point"}}}const Be=0,B=1,Ke=[0,0,0,0],U=[],xe={MODIFYSTART:"modifystart",MODIFYEND:"modifyend"};class we extends ge{constructor(e,t,s){super(e),this.features=t,this.mapBrowserEvent=s}}let Ms=class extends ue{constructor(e){super(e),this.on,this.once,this.un,this.boundHandleFeatureChange_=this.handleFeatureChange_.bind(this),this.condition_=e.condition?e.condition:$t,this.defaultDeleteCondition_=function(s){return Ht(s)&&Wt(s)},this.deleteCondition_=e.deleteCondition?e.deleteCondition:this.defaultDeleteCondition_,this.insertVertexCondition_=e.insertVertexCondition?e.insertVertexCondition:re,this.vertexFeature_=null,this.vertexSegments_=null,this.lastPixel_=[0,0],this.ignoreNextSingleClick_=!1,this.featuresBeingModified_=null,this.rBush_=new rt,this.pixelTolerance_=e.pixelTolerance!==void 0?e.pixelTolerance:10,this.snappedToVertex_=!1,this.changingFeature_=!1,this.dragSegments_=[],this.overlay_=new Le({source:new Ae({useSpatialIndex:!1,wrapX:!!e.wrapX}),style:e.style?e.style:Ls(),updateWhileAnimating:!0,updateWhileInteracting:!0}),this.SEGMENT_WRITERS_={Point:this.writePointGeometry_.bind(this),LineString:this.writeLineStringGeometry_.bind(this),LinearRing:this.writeLineStringGeometry_.bind(this),Polygon:this.writePolygonGeometry_.bind(this),MultiPoint:this.writeMultiPointGeometry_.bind(this),MultiLineString:this.writeMultiLineStringGeometry_.bind(this),MultiPolygon:this.writeMultiPolygonGeometry_.bind(this),Circle:this.writeCircleGeometry_.bind(this),GeometryCollection:this.writeGeometryCollectionGeometry_.bind(this)},this.source_=null,this.hitDetection_=null;let t;if(e.features?t=e.features:e.source&&(this.source_=e.source,t=new j(this.source_.getFeatures()),this.source_.addEventListener(he.ADDFEATURE,this.handleSourceAdd_.bind(this)),this.source_.addEventListener(he.REMOVEFEATURE,this.handleSourceRemove_.bind(this))),!t)throw new Error("The modify interaction requires features, a source or a layer");e.hitDetection&&(this.hitDetection_=e.hitDetection),this.features_=t,this.features_.forEach(this.addFeature_.bind(this)),this.features_.addEventListener(ae.ADD,this.handleFeatureAdd_.bind(this)),this.features_.addEventListener(ae.REMOVE,this.handleFeatureRemove_.bind(this)),this.lastPointerEvent_=null,this.delta_=[0,0],this.snapToPointer_=e.snapToPointer===void 0?!this.hitDetection_:e.snapToPointer}addFeature_(e){const t=e.getGeometry();if(t){const i=this.SEGMENT_WRITERS_[t.getType()];i&&i(e,t)}const s=this.getMap();s&&s.isRendered()&&this.getActive()&&this.handlePointerAtPixel_(s.getCoordinateFromPixel(this.lastPixel_)),e.addEventListener(K.CHANGE,this.boundHandleFeatureChange_)}willModifyFeatures_(e,t){if(!this.featuresBeingModified_){this.featuresBeingModified_=new j;const s=this.featuresBeingModified_.getArray();for(let i=0,n=t.length;i<n;++i){const r=t[i].feature;r&&!s.includes(r)&&this.featuresBeingModified_.push(r)}this.featuresBeingModified_.getLength()===0?this.featuresBeingModified_=null:this.dispatchEvent(new we(xe.MODIFYSTART,this.featuresBeingModified_,e))}}removeFeature_(e){this.removeFeatureSegmentData_(e),this.vertexFeature_&&this.features_.getLength()===0&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null),e.removeEventListener(K.CHANGE,this.boundHandleFeatureChange_)}removeFeatureSegmentData_(e){const t=this.rBush_,s=[];t.forEach(function(i){e===i.feature&&s.push(i)});for(let i=s.length-1;i>=0;--i){const n=s[i];for(let r=this.dragSegments_.length-1;r>=0;--r)this.dragSegments_[r][0]===n&&this.dragSegments_.splice(r,1);t.remove(n)}}setActive(e){this.vertexFeature_&&!e&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null),super.setActive(e)}setMap(e){this.overlay_.setMap(e),super.setMap(e)}getOverlay(){return this.overlay_}handleSourceAdd_(e){e.feature&&this.features_.push(e.feature)}handleSourceRemove_(e){e.feature&&this.features_.remove(e.feature)}handleFeatureAdd_(e){this.addFeature_(e.element)}handleFeatureChange_(e){if(!this.changingFeature_){const t=e.target;this.removeFeature_(t),this.addFeature_(t)}}handleFeatureRemove_(e){this.removeFeature_(e.element)}writePointGeometry_(e,t){const s=t.getCoordinates(),i={feature:e,geometry:t,segment:[s,s]};this.rBush_.insert(t.getExtent(),i)}writeMultiPointGeometry_(e,t){const s=t.getCoordinates();for(let i=0,n=s.length;i<n;++i){const r=s[i],o={feature:e,geometry:t,depth:[i],index:i,segment:[r,r]};this.rBush_.insert(t.getExtent(),o)}}writeLineStringGeometry_(e,t){const s=t.getCoordinates();for(let i=0,n=s.length-1;i<n;++i){const r=s.slice(i,i+2),o={feature:e,geometry:t,index:i,segment:r};this.rBush_.insert(x(r),o)}}writeMultiLineStringGeometry_(e,t){const s=t.getCoordinates();for(let i=0,n=s.length;i<n;++i){const r=s[i];for(let o=0,a=r.length-1;o<a;++o){const l=r.slice(o,o+2),d={feature:e,geometry:t,depth:[i],index:o,segment:l};this.rBush_.insert(x(l),d)}}}writePolygonGeometry_(e,t){const s=t.getCoordinates();for(let i=0,n=s.length;i<n;++i){const r=s[i];for(let o=0,a=r.length-1;o<a;++o){const l=r.slice(o,o+2),d={feature:e,geometry:t,depth:[i],index:o,segment:l};this.rBush_.insert(x(l),d)}}}writeMultiPolygonGeometry_(e,t){const s=t.getCoordinates();for(let i=0,n=s.length;i<n;++i){const r=s[i];for(let o=0,a=r.length;o<a;++o){const l=r[o];for(let d=0,g=l.length-1;d<g;++d){const c=l.slice(d,d+2),u={feature:e,geometry:t,depth:[o,i],index:d,segment:c};this.rBush_.insert(x(c),u)}}}}writeCircleGeometry_(e,t){const s=t.getCenter(),i={feature:e,geometry:t,index:Be,segment:[s,s]},n={feature:e,geometry:t,index:B,segment:[s,s]},r=[i,n];i.featureSegments=r,n.featureSegments=r,this.rBush_.insert(me(s),i);let o=t;this.rBush_.insert(o.getExtent(),n)}writeGeometryCollectionGeometry_(e,t){const s=t.getGeometriesArray();for(let i=0;i<s.length;++i){const n=s[i],r=this.SEGMENT_WRITERS_[n.getType()];r(e,n)}}createOrUpdateVertexFeature_(e,t,s,i){let n=this.vertexFeature_;return n?n.getGeometry().setCoordinates(e):(n=new k(new R(e)),this.vertexFeature_=n,this.overlay_.getSource().addFeature(n)),n.set("features",t),n.set("geometries",s),n.set("existing",i),n}handleEvent(e){if(!e.originalEvent)return!0;this.lastPointerEvent_=e;let t;return!e.map.getView().getInteracting()&&e.type==F.POINTERMOVE&&!this.handlingDownUpSequence&&this.handlePointerMove_(e),this.vertexFeature_&&this.deleteCondition_(e)&&(e.type!=F.SINGLECLICK||!this.ignoreNextSingleClick_?t=this.removePoint():t=!0),e.type==F.SINGLECLICK&&(this.ignoreNextSingleClick_=!1),super.handleEvent(e)&&!t}findInsertVerticesAndUpdateDragSegments_(e){this.handlePointerAtPixel_(e),this.dragSegments_.length=0,this.featuresBeingModified_=null;const t=this.vertexFeature_;if(!t)return;this.getMap().getView().getProjection();const s=[],i=t.getGeometry().getCoordinates(),n=x([i]),r=this.rBush_.getInExtent(n),o={};r.sort(Is);for(let a=0,l=r.length;a<l;++a){const d=r[a],g=d.segment;let c=S(d.geometry);const u=d.depth;if(u&&(c+="-"+u.join("-")),o[c]||(o[c]=new Array(2)),d.geometry.getType()==="Circle"&&d.index===B){const f=Xe(e,d);T(f,i)&&!o[c][0]&&(this.dragSegments_.push([d,0]),o[c][0]=d);continue}if(T(g[0],i)&&!o[c][0]){this.dragSegments_.push([d,0]),o[c][0]=d;continue}if(T(g[1],i)&&!o[c][1]){if(o[c][0]&&o[c][0].index===0){let f=d.geometry.getCoordinates();switch(d.geometry.getType()){case"LineString":case"MultiLineString":continue;case"MultiPolygon":f=f[u[1]];case"Polygon":if(d.index!==f[u[0]].length-2)continue;break}}this.dragSegments_.push([d,1]),o[c][1]=d;continue}S(g)in this.vertexSegments_&&!o[c][0]&&!o[c][1]&&s.push(d)}return s}handleDragEvent(e){this.ignoreNextSingleClick_=!1,this.willModifyFeatures_(e,this.dragSegments_.map(([n])=>n));const t=[e.coordinate[0]+this.delta_[0],e.coordinate[1]+this.delta_[1]],s=[],i=[];for(let n=0,r=this.dragSegments_.length;n<r;++n){const o=this.dragSegments_[n],a=o[0],l=a.feature;s.includes(l)||s.push(l);const d=a.geometry;i.includes(d)||i.push(d);const g=a.depth;let c;const u=a.segment,f=o[1];for(;t.length<d.getStride();)t.push(u[f][t.length]);switch(d.getType()){case"Point":c=t,u[0]=t,u[1]=t;break;case"MultiPoint":c=d.getCoordinates(),c[a.index]=t,u[0]=t,u[1]=t;break;case"LineString":c=d.getCoordinates(),c[a.index+f]=t,u[f]=t;break;case"MultiLineString":c=d.getCoordinates(),c[g[0]][a.index+f]=t,u[f]=t;break;case"Polygon":c=d.getCoordinates(),c[g[0]][a.index+f]=t,u[f]=t;break;case"MultiPolygon":c=d.getCoordinates(),c[g[1]][g[0]][a.index+f]=t,u[f]=t;break;case"Circle":const _=d;if(u[0]=t,u[1]=t,a.index===Be)this.changingFeature_=!0,_.setCenter(t),this.changingFeature_=!1;else{this.changingFeature_=!0,e.map.getView().getProjection();let m=oe(y(_.getCenter()),y(t));_.setRadius(m),this.changingFeature_=!1}break}c&&this.setGeometryCoordinates_(d,c)}this.createOrUpdateVertexFeature_(t,s,i,!0)}handleDownEvent(e){if(!this.condition_(e))return!1;const t=e.coordinate,s=this.findInsertVerticesAndUpdateDragSegments_(t);if(s!=null&&s.length&&this.insertVertexCondition_(e)&&(this.willModifyFeatures_(e,s),this.vertexFeature_)){const i=this.vertexFeature_.getGeometry().getCoordinates();for(let n=s.length-1;n>=0;--n)this.insertVertex_(s[n],i);this.ignoreNextSingleClick_=!0}return!!this.vertexFeature_}handleUpEvent(e){for(let t=this.dragSegments_.length-1;t>=0;--t){const s=this.dragSegments_[t][0],i=s.geometry;if(i.getType()==="Circle"){const n=i,r=n.getCenter(),o=s.featureSegments[0],a=s.featureSegments[1];o.segment[0]=r,o.segment[1]=r,a.segment[0]=r,a.segment[1]=r,this.rBush_.update(me(r),o);let l=n;this.rBush_.update(l.getExtent(),a)}else this.rBush_.update(x(s.segment),s)}return this.featuresBeingModified_&&(this.dispatchEvent(new we(xe.MODIFYEND,this.featuresBeingModified_,e)),this.featuresBeingModified_=null),!1}handlePointerMove_(e){this.lastPixel_=e.pixel,this.handlePointerAtPixel_(e.coordinate)}handlePointerAtPixel_(e){const t=this.getMap(),s=t.getPixelFromCoordinate(e);t.getView().getProjection();const i=function(o,a){return qe(e,o)-qe(e,a)};let n,r;if(this.hitDetection_){const o=typeof this.hitDetection_=="object"?a=>a===this.hitDetection_:void 0;t.forEachFeatureAtPixel(s,(a,l,d)=>{d&&d.getType()==="Point"&&(d=new R(q(d.getCoordinates())));const g=d||a.getGeometry();if(g&&g.getType()==="Point"&&a instanceof k&&this.features_.getArray().includes(a)){r=g;const c=a.getGeometry().getFlatCoordinates().slice(0,2);n=[{feature:a,geometry:r,segment:[c,c]}]}return!0},{layerFilter:o})}if(!n){const o=zt(me(e,Ke)),a=t.getView().getResolution()*this.pixelTolerance_,l=et(tt(o,a,Ke));n=this.rBush_.getInExtent(l)}if(n&&n.length>0){const o=n.sort(i)[0],a=o.segment;let l=Xe(e,o);const d=t.getPixelFromCoordinate(l);let g=oe(s,d);if(r||g<=this.pixelTolerance_){const c={};if(c[S(a)]=!0,this.snapToPointer_||(this.delta_[0]=l[0]-e[0],this.delta_[1]=l[1]-e[1]),o.geometry.getType()==="Circle"&&o.index===B)this.snappedToVertex_=!0,this.createOrUpdateVertexFeature_(l,[o.feature],[o.geometry],this.snappedToVertex_);else{const u=t.getPixelFromCoordinate(a[0]),f=t.getPixelFromCoordinate(a[1]),_=b(d,u),m=b(d,f);if(g=Math.sqrt(Math.min(_,m)),this.snappedToVertex_=g<=this.pixelTolerance_,!this.snappedToVertex_&&!this.insertVertexCondition_(this.lastPointerEvent_)){this.vertexFeature_&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null);return}this.snappedToVertex_&&(l=_>m?a[1]:a[0]),this.createOrUpdateVertexFeature_(l,[o.feature],[o.geometry],this.snappedToVertex_);const p={};p[S(o.geometry)]=!0;for(let C=1,w=n.length;C<w;++C){const P=n[C].segment;if(T(a[0],P[0])&&T(a[1],P[1])||T(a[0],P[1])&&T(a[1],P[0])){const Ge=S(n[C].geometry);Ge in p||(p[Ge]=!0,c[S(P)]=!0)}else break}}this.vertexSegments_=c;return}}this.vertexFeature_&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null)}insertVertex_(e,t){const s=e.segment,i=e.feature,n=e.geometry,r=e.depth,o=e.index;let a;for(;t.length<n.getStride();)t.push(0);switch(n.getType()){case"MultiLineString":a=n.getCoordinates(),a[r[0]].splice(o+1,0,t);break;case"Polygon":a=n.getCoordinates(),a[r[0]].splice(o+1,0,t);break;case"MultiPolygon":a=n.getCoordinates(),a[r[1]][r[0]].splice(o+1,0,t);break;case"LineString":a=n.getCoordinates(),a.splice(o+1,0,t);break;default:return!1}this.setGeometryCoordinates_(n,a);const l=this.rBush_;l.remove(e),this.updateSegmentIndices_(n,o,r,1);const d={segment:[s[0],t],feature:i,geometry:n,depth:r,index:o};l.insert(x(d.segment),d),this.dragSegments_.push([d,1]);const g={segment:[t,s[1]],feature:i,geometry:n,depth:r,index:o+1};return l.insert(x(g.segment),g),this.dragSegments_.push([g,0]),!0}updatePointer_(e){var t;return e&&this.findInsertVerticesAndUpdateDragSegments_(e),(t=this.vertexFeature_)==null?void 0:t.getGeometry().getCoordinates()}getPoint(){var t;const e=(t=this.vertexFeature_)==null?void 0:t.getGeometry().getCoordinates();return e?q(e,this.getMap().getView().getProjection()):null}canRemovePoint(){if(!this.vertexFeature_||this.vertexFeature_.get("geometries").every(s=>s.getType()==="Circle"||s.getType().endsWith("Point")))return!1;const e=this.vertexFeature_.getGeometry().getCoordinates();return this.rBush_.getInExtent(x([e])).some(({segment:s})=>T(s[0],e)||T(s[1],e))}removePoint(e){if(e&&(e=y(e,this.getMap().getView().getProjection()),this.updatePointer_(e)),!this.lastPointerEvent_||this.lastPointerEvent_&&this.lastPointerEvent_.type!=F.POINTERDRAG){const t=this.lastPointerEvent_;this.willModifyFeatures_(t,this.dragSegments_.map(([i])=>i));const s=this.removeVertex_();return this.featuresBeingModified_&&this.dispatchEvent(new we(xe.MODIFYEND,this.featuresBeingModified_,t)),this.featuresBeingModified_=null,s}return!1}removeVertex_(){const e=this.dragSegments_,t={};let s=!1,i,n,r,o,a,l,d,g,c,u,f;for(a=e.length-1;a>=0;--a)r=e[a],u=r[0],f=S(u.feature),u.depth&&(f+="-"+u.depth.join("-")),f in t||(t[f]={}),r[1]===0?(t[f].right=u,t[f].index=u.index):r[1]==1&&(t[f].left=u,t[f].index=u.index+1);for(f in t){switch(c=t[f].right,d=t[f].left,l=t[f].index,g=l-1,d!==void 0?u=d:u=c,g<0&&(g=0),o=u.geometry,n=o.getCoordinates(),i=n,s=!1,o.getType()){case"MultiLineString":n[u.depth[0]].length>2&&(n[u.depth[0]].splice(l,1),s=!0);break;case"LineString":n.length>2&&(n.splice(l,1),s=!0);break;case"MultiPolygon":i=i[u.depth[1]];case"Polygon":i=i[u.depth[0]],i.length>4&&(l==i.length-1&&(l=0),i.splice(l,1),s=!0,l===0&&(i.pop(),i.push(i[0]),g=i.length-1));break}if(s){this.setGeometryCoordinates_(o,n);const _=[];if(d!==void 0&&(this.rBush_.remove(d),_.push(d.segment[0])),c!==void 0&&(this.rBush_.remove(c),_.push(c.segment[1])),d!==void 0&&c!==void 0){const m={depth:u.depth,feature:u.feature,geometry:u.geometry,index:g,segment:_};this.rBush_.insert(x(m.segment),m)}this.updateSegmentIndices_(o,l,u.depth,-1),this.vertexFeature_&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null),e.length=0}}return s}canInsertPoint(){if(!this.vertexFeature_||this.vertexFeature_.get("geometries").every(s=>s.getType()==="Circle"||s.getType().endsWith("Point")))return!1;const e=this.vertexFeature_.getGeometry().getCoordinates();return this.rBush_.getInExtent(x([e])).some(({segment:s})=>!(T(s[0],e)||T(s[1],e)))}insertPoint(e){var i;const t=e?y(e,this.getMap().getView().getProjection()):(i=this.vertexFeature_)==null?void 0:i.getGeometry().getCoordinates();return t?this.findInsertVerticesAndUpdateDragSegments_(t).reduce((n,r)=>n||this.insertVertex_(r,t),!1):!1}setGeometryCoordinates_(e,t){this.changingFeature_=!0,e.setCoordinates(t),this.changingFeature_=!1}updateSegmentIndices_(e,t,s,i){this.rBush_.forEachInExtent(e.getExtent(),function(n){n.geometry===e&&(s===void 0||n.depth===void 0||Zt(n.depth,s))&&n.index>t&&(n.index+=i)})}};function Is(h,e){return h.index-e.index}function qe(h,e,t){const s=e.geometry;if(s.getType()==="Circle"){let n=s;if(e.index===B){const r=b(n.getCenter(),y(h)),o=Math.sqrt(r)-n.getRadius();return o*o}}const i=y(h);return U[0]=y(e.segment[0]),U[1]=y(e.segment[1]),Jt(i,U)}function Xe(h,e,t){const s=e.geometry;if(s.getType()==="Circle"&&e.index===B)return q(s.getClosestPoint(y(h)));const i=y(h);return U[0]=y(e.segment[0]),U[1]=y(e.segment[1]),q(st(i,U))}function Ls(){const h=Qe();return function(e,t){return h.Point}}class As{constructor(e,t){v(this,"modifyInteraction");this.map=e,this.modifyInteraction=new Ms(t),this.map.addInteraction(this.modifyInteraction)}destroy(){this.map.removeInteraction(this.modifyInteraction)}getInteraction(){return this.modifyInteraction}}const Fe={TRANSLATESTART:"translatestart",TRANSLATING:"translating",TRANSLATEEND:"translateend"};class Pe extends ge{constructor(e,t,s,i,n){super(e),this.features=t,this.coordinate=s,this.startCoordinate=i,this.mapBrowserEvent=n}}let Gs=class extends ue{constructor(e){e=e||{},super(e),this.on,this.once,this.un,this.lastCoordinate_=null,this.startCoordinate_=null,this.features_=e.features!==void 0?e.features:null;let t;if(e.layers&&!this.features_)if(typeof e.layers=="function")t=e.layers;else{const s=e.layers;t=function(i){return s.includes(i)}}else t=ne;this.layerFilter_=t,this.filter_=e.filter&&!this.features_?e.filter:ne,this.hitTolerance_=e.hitTolerance?e.hitTolerance:0,this.condition_=e.condition?e.condition:re,this.lastFeature_=null,this.addChangeListener(Je.ACTIVE,this.handleActiveChanged_)}handleDownEvent(e){if(!e.originalEvent||!this.condition_(e))return!1;if(this.lastFeature_=this.featuresAtPixel_(e.pixel,e.map),!this.lastCoordinate_&&this.lastFeature_){this.startCoordinate_=e.coordinate,this.lastCoordinate_=e.coordinate,this.handleMoveEvent(e);const t=this.features_||new j([this.lastFeature_]);return this.dispatchEvent(new Pe(Fe.TRANSLATESTART,t,e.coordinate,this.startCoordinate_,e)),!0}return!1}handleUpEvent(e){if(this.lastCoordinate_){this.lastCoordinate_=null,this.handleMoveEvent(e);const t=this.features_||new j([this.lastFeature_]);return this.dispatchEvent(new Pe(Fe.TRANSLATEEND,t,e.coordinate,this.startCoordinate_,e)),this.startCoordinate_=null,!0}return!1}handleDragEvent(e){if(this.lastCoordinate_){const t=e.coordinate;e.map.getView().getProjection();const s=y(t),i=y(this.lastCoordinate_),n=s[0]-i[0],r=s[1]-i[1],o=this.features_||new j([this.lastFeature_]);o.forEach(function(a){const l=a.getGeometry();l.translate(n,r),a.setGeometry(l)}),this.lastCoordinate_=t,this.dispatchEvent(new Pe(Fe.TRANSLATING,o,t,this.startCoordinate_,e))}}handleMoveEvent(e){const t=e.map.getViewport();this.featuresAtPixel_(e.pixel,e.map)?(t.classList.remove(this.lastCoordinate_?"ol-grab":"ol-grabbing"),t.classList.add(this.lastCoordinate_?"ol-grabbing":"ol-grab")):t.classList.remove("ol-grab","ol-grabbing")}featuresAtPixel_(e,t){return t.forEachFeatureAtPixel(e,(s,i)=>{if(!(!(s instanceof k)||!this.filter_(s,i))&&!(this.features_&&!this.features_.getArray().includes(s)))return s},{layerFilter:this.layerFilter_,hitTolerance:this.hitTolerance_})}getHitTolerance(){return this.hitTolerance_}setHitTolerance(e){this.hitTolerance_=e}setMap(e){const t=this.getMap();super.setMap(e),this.updateState_(t)}handleActiveChanged_(){this.updateState_(null)}updateState_(e){let t=this.getMap();const s=this.getActive();(!t||!s)&&(t=t||e,t&&t.getViewport().classList.remove("ol-grab","ol-grabbing"))}};class Rs{constructor(e,t){v(this,"translateInteraction");this.map=e,this.translateInteraction=new Gs(t),this.map.addInteraction(this.translateInteraction)}destroy(){this.map.removeInteraction(this.translateInteraction)}getInteraction(){return this.translateInteraction}}const Te={SNAP:"snap",UNSNAP:"unsnap"};class Ee extends ge{constructor(e,t){super(e),this.vertex=t.vertex,this.vertexPixel=t.vertexPixel,this.feature=t.feature,this.segment=t.segment}}const De={Circle(h,e){const s=ts(h);return De.Polygon(s)},GeometryCollection(h,e){const t=[],s=h.getGeometriesArray();for(let i=0;i<s.length;++i){const n=De[s[i].getType()];n&&t.push(n(s[i],e))}return t.flat()},LineString(h){const e=[],t=h.getFlatCoordinates(),s=h.getStride();for(let i=0,n=t.length-s;i<n;i+=s)e.push([t.slice(i,i+2),t.slice(i+s,i+s+2)]);return e},MultiLineString(h){const e=[],t=h.getFlatCoordinates(),s=h.getStride(),i=h.getEnds();let n=0;for(let r=0,o=i.length;r<o;++r){const a=i[r];for(let l=n,d=a-s;l<d;l+=s)e.push([t.slice(l,l+2),t.slice(l+s,l+s+2)]);n=a}return e},MultiPoint(h){const e=[],t=h.getFlatCoordinates(),s=h.getStride();for(let i=0,n=t.length-s;i<n;i+=s)e.push([t.slice(i,i+2)]);return e},MultiPolygon(h){const e=[],t=h.getFlatCoordinates(),s=h.getStride(),i=h.getEndss();let n=0;for(let r=0,o=i.length;r<o;++r){const a=i[r];for(let l=0,d=a.length;l<d;++l){const g=a[l];for(let c=n,u=g-s;c<u;c+=s)e.push([t.slice(c,c+2),t.slice(c+s,c+s+2)]);n=g}}return e},Point(h){return[[h.getFlatCoordinates().slice(0,2)]]},Polygon(h){const e=[],t=h.getFlatCoordinates(),s=h.getStride(),i=h.getEnds();let n=0;for(let r=0,o=i.length;r<o;++r){const a=i[r];for(let l=n,d=a-s;l<d;l+=s)e.push([t.slice(l,l+2),t.slice(l+s,l+s+2)]);n=a}return e}};function Ye(h){return h.feature?h.feature:h.element?h.element:null}const Se=[],D=[],O=[];let bs=class extends ue{constructor(e){e=e||{};const t=e;t.handleDownEvent||(t.handleDownEvent=ne),t.stopDown||(t.stopDown=Ze),super(t),this.on,this.once,this.un,this.source_=e.source?e.source:null,this.vertex_=e.vertex!==void 0?e.vertex:!0,this.edge_=e.edge!==void 0?e.edge:!0,this.intersection_=e.intersection!==void 0?e.intersection:!1,this.features_=e.features?e.features:null,this.featuresListenerKeys_=[],this.featureChangeListenerKeys_={},this.indexedFeaturesExtents_={},this.pendingFeatures_={},this.pixelTolerance_=e.pixelTolerance!==void 0?e.pixelTolerance:10,this.rBush_=new rt,this.snapped_=null,this.segmenters_=Object.assign({},De,e.segmenters)}addFeature(e,t){t=t!==void 0?t:!0;const s=S(e),i=e.getGeometry();if(i){const n=this.segmenters_[i.getType()];if(n){this.indexedFeaturesExtents_[s]=i.getExtent(Qt());const r=n(i,this.getMap().getView().getProjection());let o=r.length;for(let a=0;a<o;++a){const l=r[a];D[a]=x(l),O[a]={feature:e,segment:l}}if(D.length=o,O.length=o,this.intersection_)for(let a=0,l=r.length;a<l;++a){const d=r[a];if(d.length===1)continue;const g=D[a];for(let u=0,f=r.length;u<f;++u){if(a===u||a-1===u||a+1===u)continue;const _=r[u];if(!He(g,D[u]))continue;const m=Oe(d,_);if(!m)continue;const p=[m];D[o]=x(p),O[o++]={feature:e,segment:p,isIntersection:!0}}const c=this.rBush_.getInExtent(D[a]);for(const{segment:u}of c){if(u.length===1)continue;const f=Oe(d,u);if(!f)continue;const _=[f];D[o]=x(_),O[o++]={feature:e,segment:_,isIntersection:!0}}}o===1?this.rBush_.insert(D[0],O[0]):this.rBush_.load(D,O)}}t&&(this.featureChangeListenerKeys_[s]=L(e,K.CHANGE,this.handleFeatureChange_,this))}getFeatures_(){let e;return this.features_?e=this.features_:this.source_&&(e=this.source_.getFeatures()),e}areSnapDataEqual_(e,t){return e.segment===t.segment&&e.feature===t.feature}handleEvent(e){const t=this.snapTo(e.pixel,e.coordinate,e.map);return t?(e.coordinate=t.vertex.slice(0,2),e.pixel=t.vertexPixel,this.snapped_&&!this.areSnapDataEqual_(this.snapped_,t)&&this.dispatchEvent(new Ee(Te.UNSNAP,this.snapped_)),this.snapped_={vertex:e.coordinate,vertexPixel:e.pixel,feature:t.feature,segment:t.segment},this.dispatchEvent(new Ee(Te.SNAP,this.snapped_))):this.snapped_&&(this.dispatchEvent(new Ee(Te.UNSNAP,this.snapped_)),this.snapped_=null),super.handleEvent(e)}handleFeatureAdd_(e){const t=Ye(e);t&&this.addFeature(t)}handleFeatureRemove_(e){const t=Ye(e);t&&this.removeFeature(t)}handleFeatureChange_(e){const t=e.target;if(this.handlingDownUpSequence){const s=S(t);s in this.pendingFeatures_||(this.pendingFeatures_[s]=t)}else this.updateFeature_(t)}handleUpEvent(e){const t=Object.values(this.pendingFeatures_);if(t.length)for(const s of t)this.updateFeature_(s);return!1}removeFeature(e,t){const s=t!==void 0?t:!0,i=S(e),n=this.indexedFeaturesExtents_[i];if(n){const r=this.rBush_,o=[];r.forEachInExtent(n,function(a){e===a.feature&&o.push(a)});for(let a=o.length-1;a>=0;--a)r.remove(o[a])}s&&(se(this.featureChangeListenerKeys_[i]),delete this.featureChangeListenerKeys_[i])}setMap(e){const t=this.getMap(),s=this.featuresListenerKeys_;let i=this.getFeatures_();if(Array.isArray(i)||(i=i.getArray()),t&&(s.forEach(se),s.length=0,this.rBush_.clear(),Object.values(this.featureChangeListenerKeys_).forEach(se),this.featureChangeListenerKeys_={}),super.setMap(e),e){this.features_?s.push(L(this.features_,ae.ADD,this.handleFeatureAdd_,this),L(this.features_,ae.REMOVE,this.handleFeatureRemove_,this)):this.source_&&s.push(L(this.source_,he.ADDFEATURE,this.handleFeatureAdd_,this),L(this.source_,he.REMOVEFEATURE,this.handleFeatureRemove_,this));for(const n of i)this.addFeature(n)}}snapTo(e,t,s){s.getView().getProjection();const i=y(t),n=et(tt(x([i]),s.getView().getResolution()*this.pixelTolerance_)),r=this.rBush_.getInExtent(n),o=r.length;if(o===0)return null;let a,l=1/0,d,g=null,c;const u=this.pixelTolerance_*this.pixelTolerance_,f=()=>{if(a){const _=s.getPixelFromCoordinate(a);if(b(e,_)<=u&&(c&&this.intersection_||!c&&(this.vertex_||this.edge_)))return{vertex:a,vertexPixel:[Math.round(_[0]),Math.round(_[1])],feature:d,segment:g}}return null};if(this.vertex_||this.intersection_){for(let m=0;m<o;++m){const p=r[m];if(p.feature.getGeometry().getType()!=="Circle")for(const C of p.segment){const w=y(C),P=b(i,w);P<l&&(a=C,l=P,d=p.feature,c=p.isIntersection)}}const _=f();if(_)return _}if(this.edge_){for(let m=0;m<o;++m){let p=null;const C=r[m];if(C.feature.getGeometry().getType()==="Circle"){let w=C.feature.getGeometry();p=es(i,w)}else{const[w,P]=C.segment;P&&(Se[0]=y(w),Se[1]=y(P),p=st(i,Se))}if(p){const w=b(i,p);w<l&&(a=q(p),g=C.feature.getGeometry().getType()==="Circle"?null:C.segment,l=w,d=C.feature)}}const _=f();if(_)return _}return null}updateFeature_(e){this.removeFeature(e,!1),this.addFeature(e,!1)}};class Os{constructor(e,t){v(this,"snapInteraction");this.map=e,this.snapInteraction=new bs(t),this.map.addInteraction(this.snapInteraction)}destroy(){this.map.removeInteraction(this.snapInteraction)}getInteraction(){return this.snapInteraction}}const E=ss.createEmptyMap(),de="layer1-id",Vs="background1-id",Ns="point-interaction-uid",js="line-interaction-uid",Us=new Le({source:new Ae({features:new j([new k])})}),Bs=new is({source:new ns}),$e=h=>{document.querySelector("#console .text").textContent=h};E.setView(new rs({center:[0,0],zoom:2}));E.setTarget("map");let A=new ot(E);A.addLayer(Us,de);const Ks=new os(E);Ks.addLayer(Bs,Vs);let ce,ke,Me,I;const qs=[],Xs=()=>{A=new ot(E);const h=A==null?void 0:A.getLayer(de),e=h==null?void 0:h.getSource();if(!h||!e||!E){console.error("No layer source or no map to draw in.");return}ws(h,te),I=new xs("Delete");const t=ee.getDefaultPointOptions(e);t.style=te,t.condition=()=>!(I!=null&&I.isKeyDown()),ce=new ee(E,t,Ns);const s=ee.getDefaultLineOptions(e);s.style=te,s.condition=()=>!(I!=null&&I.isKeyDown()),ke=new ee(E,s,js),Me=new As(E,{deleteCondition:ps(as.overEvery(hs,ys(()=>I.isKeyDown())),Ys.bind(void 0)),source:e,style:te}),new Rs(E,{layers:[h],condition:ls}),new Os(E,{source:e}),qs.push(ce.getInteraction().on("drawend",i=>{$e(`Point ${i.feature.get("ol_uid")} added.`)}),ke.getInteraction().on("drawend",i=>{$e(`Line ${i.feature.get("ol_uid")} added.`)}))},te=h=>{const e=h==null?void 0:h.getGeometry(),t=e==null?void 0:e.getType();if(["MultiPoint","Point"].includes(`${t}`)&&e){const s=e.getCoordinates()[0]||0,i=Math.round(Math.abs(s)/(20037508/2)*255);return new Ve({image:new ds({radius:8,fill:new cs({color:`rgba(${i}, 0, 0, 0.7)`}),stroke:new Ne({color:`rgba(${i}, 0, 0, 0.7)`})})})}else return["LineString","MultiLineString"].includes(`${t}`)&&e?new Ve({stroke:new Ne({color:"rgba(200, 150, 0, 0.8)",width:4})}):us},Ys=h=>{setTimeout(()=>$s(h),20)},$s=h=>{h.map.forEachFeatureAtPixel(h.pixel,e=>{var i;if(!A||e instanceof ms)return;const t=e.getGeometry();if(!t||t.getType()==="LineString"&&t.getCoordinates().length>2)return;(((i=A.getFeaturesCollection(de))==null?void 0:i.getArray())||[]).includes(e)&&(A.removeFeatures(de,[e]),Me.getInteraction().setActive(!1),Me.getInteraction().setActive(!0))})};Xs();ce.setActive(!0);const Hs=document.getElementById("type");Hs.addEventListener("change",h=>{h.target.value==="point"?ce.setActive(!0):ke.setActive(!0)});
