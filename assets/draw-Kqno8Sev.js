import{S as $,c as Tt,i as tt,f as Ft,d as wt,r as St,G as Pt,u as K,l as M,E as X,a as z,b as Et,e as vt,g as Mt,h as L,m as kt,j as Dt,k as Gt,n as st,o as Lt,p as At,q as it,s as It,t as Rt,v as bt,w as Vt,x as Ot,y as Nt,z as Ge,P as A,A as jt,B as Ut,C as Bt,D as Kt,F as qt,H as be,I as Xt,J as Yt,K as Ht,L as Wt,M as ae,N as $t,O as zt,Q as b,R as Zt,T as Jt,U as fe,V as nt,W as he,X as p,Y as I,Z as Qt,_ as O,$ as Ve,a0 as rt,a1 as T,a2 as es,a3 as C,a4 as Oe,a5 as ot,a6 as at,a7 as _e,a8 as N,a9 as ts,aa as ss,ab as is,ac as le,ad as pe,ae as S,af as w,ag as Le,ah as Y,ai as ns,aj as ht,ak as lt,al as rs,am as os,an as as,ao as Ne,ap as hs,aq as ls,ar as ds,as as cs,at as ke,au as je,av as us,aw as Ue,ax as Z,ay as gs,az as fs,aA as _s,aB as ms,aC as ys,aD as ps,aE as Cs,aF as xs,aG as Be,aH as Ts,aI as Fs}from"./background-layer-group-B399lWTM.js";import{l as ws,i as dt,a as ct,b as Ss,c as Ps,V as Ae,d as Ie,F as E,R as ut,e as de,O as gt,f as Es}from"./overlay-layer-group-8OOqePN5.js";class me extends ${constructor(e,t,s){super(),s!==void 0&&t===void 0?this.setFlatCoordinates(s,e):(t=t||0,this.setCenterAndRadius(e,t,s))}clone(){const e=new me(this.flatCoordinates.slice(),void 0,this.layout);return e.applyProperties(this),e}closestPointXY(e,t,s,i){const n=this.flatCoordinates,r=e-n[0],o=t-n[1],a=r*r+o*o;if(a<i){if(a===0)for(let h=0;h<this.stride;++h)s[h]=n[h];else{const h=this.getRadius()/Math.sqrt(a);s[0]=n[0]+h*r,s[1]=n[1]+h*o;for(let d=2;d<this.stride;++d)s[d]=n[d]}return s.length=this.stride,a}return i}containsXY(e,t){const s=this.flatCoordinates,i=e-s[0],n=t-s[1];return i*i+n*n<=this.getRadiusSquared_()}getCenter(){return this.flatCoordinates.slice(0,this.stride)}computeExtent(e){const t=this.flatCoordinates,s=t[this.stride]-t[0];return Tt(t[0]-s,t[1]-s,t[0]+s,t[1]+s,e)}getRadius(){return Math.sqrt(this.getRadiusSquared_())}getRadiusSquared_(){const e=this.flatCoordinates[this.stride]-this.flatCoordinates[0],t=this.flatCoordinates[this.stride+1]-this.flatCoordinates[1];return e*e+t*t}getType(){return"Circle"}intersectsExtent(e){const t=this.getExtent();if(tt(e,t)){const s=this.getCenter();return e[0]<=s[0]&&e[2]>=s[0]||e[1]<=s[1]&&e[3]>=s[1]?!0:Ft(e,this.intersectsCoordinate.bind(this))}return!1}setCenter(e){const t=this.stride,s=this.flatCoordinates[t]-this.flatCoordinates[0],i=e.slice();i[t]=i[0]+s;for(let n=1;n<t;++n)i[t+n]=e[n];this.setFlatCoordinates(this.layout,i),this.changed()}setCenterAndRadius(e,t,s){this.setLayout(s,e,0),this.flatCoordinates||(this.flatCoordinates=[]);const i=this.flatCoordinates;let n=wt(i,0,e,this.stride);i[n++]=i[0]+t;for(let r=1,o=this.stride;r<o;++r)i[n++]=i[r];i.length=n,this.changed()}getCoordinates(){return null}setCoordinates(e,t){}setRadius(e){this.flatCoordinates[this.stride]=this.flatCoordinates[0]+e,this.changed()}rotate(e,t){const s=this.getCenter(),i=this.getStride();this.setCenter(St(s,0,s.length,i,e,t,s)),this.changed()}}me.prototype.transform;class ce extends Pt{constructor(e){super(),this.geometries_=e,this.changeEventsKeys_=[],this.listenGeometriesChange_()}unlistenGeometriesChange_(){this.changeEventsKeys_.forEach(K),this.changeEventsKeys_.length=0}listenGeometriesChange_(){const e=this.geometries_;for(let t=0,s=e.length;t<s;++t)this.changeEventsKeys_.push(M(e[t],X.CHANGE,this.changed,this))}clone(){const e=new ce(Ce(this.geometries_));return e.applyProperties(this),e}closestPointXY(e,t,s,i){if(i<z(this.getExtent(),e,t))return i;const n=this.geometries_;for(let r=0,o=n.length;r<o;++r)i=n[r].closestPointXY(e,t,s,i);return i}containsXY(e,t){const s=this.geometries_;for(let i=0,n=s.length;i<n;++i)if(s[i].containsXY(e,t))return!0;return!1}computeExtent(e){Et(e);const t=this.geometries_;for(let s=0,i=t.length;s<i;++s)vt(e,t[s].getExtent());return e}getGeometries(){return Ce(this.geometries_)}getGeometriesArray(){return this.geometries_}getGeometriesArrayRecursive(){let e=[];const t=this.geometries_;for(let s=0,i=t.length;s<i;++s)t[s].getType()===this.getType()?e=e.concat(t[s].getGeometriesArrayRecursive()):e.push(t[s]);return e}getSimplifiedGeometry(e){if(this.simplifiedGeometryRevision!==this.getRevision()&&(this.simplifiedGeometryMaxMinSquaredTolerance=0,this.simplifiedGeometryRevision=this.getRevision()),e<0||this.simplifiedGeometryMaxMinSquaredTolerance!==0&&e<this.simplifiedGeometryMaxMinSquaredTolerance)return this;const t=[],s=this.geometries_;let i=!1;for(let n=0,r=s.length;n<r;++n){const o=s[n],a=o.getSimplifiedGeometry(e);t.push(a),a!==o&&(i=!0)}return i?new ce(t):(this.simplifiedGeometryMaxMinSquaredTolerance=e,this)}getType(){return"GeometryCollection"}intersectsExtent(e){const t=this.geometries_;for(let s=0,i=t.length;s<i;++s)if(t[s].intersectsExtent(e))return!0;return!1}isEmpty(){return this.geometries_.length===0}rotate(e,t){const s=this.geometries_;for(let i=0,n=s.length;i<n;++i)s[i].rotate(e,t);this.changed()}scale(e,t,s){s||(s=Mt(this.getExtent()));const i=this.geometries_;for(let n=0,r=i.length;n<r;++n)i[n].scale(e,t,s);this.changed()}setGeometries(e){this.setGeometriesArray(Ce(e))}setGeometriesArray(e){this.unlistenGeometriesChange_(),this.geometries_=e,this.listenGeometriesChange_(),this.changed()}applyTransform(e){const t=this.geometries_;for(let s=0,i=t.length;s<i;++s)t[s].applyTransform(e);this.changed()}translate(e,t){const s=this.geometries_;for(let i=0,n=s.length;i<n;++i)s[i].translate(e,t);this.changed()}disposeInternal(){this.unlistenGeometriesChange_(),super.disposeInternal()}}function Ce(l){return l.map(e=>e.clone())}class v extends ${constructor(e,t){super(),this.flatMidpoint_=null,this.flatMidpointRevision_=-1,this.maxDelta_=-1,this.maxDeltaRevision_=-1,t!==void 0&&!Array.isArray(e[0])?this.setFlatCoordinates(t,e):this.setCoordinates(e,t)}appendCoordinate(e){L(this.flatCoordinates,e),this.changed()}clone(){const e=new v(this.flatCoordinates.slice(),this.layout);return e.applyProperties(this),e}closestPointXY(e,t,s,i){return i<z(this.getExtent(),e,t)?i:(this.maxDeltaRevision_!=this.getRevision()&&(this.maxDelta_=Math.sqrt(kt(this.flatCoordinates,0,this.flatCoordinates.length,this.stride,0)),this.maxDeltaRevision_=this.getRevision()),Dt(this.flatCoordinates,0,this.flatCoordinates.length,this.stride,this.maxDelta_,!1,e,t,s,i))}forEachSegment(e){return Gt(this.flatCoordinates,0,this.flatCoordinates.length,this.stride,e)}getCoordinateAtM(e,t){return this.layout!="XYM"&&this.layout!="XYZM"?null:(t=t!==void 0?t:!1,ws(this.flatCoordinates,0,this.flatCoordinates.length,this.stride,e,t))}getCoordinates(){return st(this.flatCoordinates,0,this.flatCoordinates.length,this.stride)}getCoordinateAt(e,t){return dt(this.flatCoordinates,0,this.flatCoordinates.length,this.stride,e,t,this.stride)}getLength(){return ct(this.flatCoordinates,0,this.flatCoordinates.length,this.stride)}getFlatMidpoint(){return this.flatMidpointRevision_!=this.getRevision()&&(this.flatMidpoint_=this.getCoordinateAt(.5,this.flatMidpoint_??void 0),this.flatMidpointRevision_=this.getRevision()),this.flatMidpoint_}getSimplifiedGeometryInternal(e){const t=[];return t.length=Lt(this.flatCoordinates,0,this.flatCoordinates.length,this.stride,e,t,0),new v(t,"XY")}getType(){return"LineString"}intersectsExtent(e){return At(this.flatCoordinates,0,this.flatCoordinates.length,this.stride,e,this.getExtent())}setCoordinates(e,t){this.setLayout(t,e,1),this.flatCoordinates||(this.flatCoordinates=[]),this.flatCoordinates.length=it(this.flatCoordinates,0,e,this.stride),this.changed()}}class H extends ${constructor(e,t,s){if(super(),this.ends_=[],this.maxDelta_=-1,this.maxDeltaRevision_=-1,Array.isArray(e[0]))this.setCoordinates(e,t);else if(t!==void 0&&s)this.setFlatCoordinates(t,e),this.ends_=s;else{const i=e,n=[],r=[];for(let a=0,h=i.length;a<h;++a){const d=i[a];L(n,d.getFlatCoordinates()),r.push(n.length)}const o=i.length===0?this.getLayout():i[0].getLayout();this.setFlatCoordinates(o,n),this.ends_=r}}appendLineString(e){L(this.flatCoordinates,e.getFlatCoordinates().slice()),this.ends_.push(this.flatCoordinates.length),this.changed()}clone(){const e=new H(this.flatCoordinates.slice(),this.layout,this.ends_.slice());return e.applyProperties(this),e}closestPointXY(e,t,s,i){return i<z(this.getExtent(),e,t)?i:(this.maxDeltaRevision_!=this.getRevision()&&(this.maxDelta_=Math.sqrt(It(this.flatCoordinates,0,this.ends_,this.stride,0)),this.maxDeltaRevision_=this.getRevision()),Rt(this.flatCoordinates,0,this.ends_,this.stride,this.maxDelta_,!1,e,t,s,i))}getCoordinateAtM(e,t,s){return this.layout!="XYM"&&this.layout!="XYZM"||this.flatCoordinates.length===0?null:(t=t!==void 0?t:!1,s=s!==void 0?s:!1,Ss(this.flatCoordinates,0,this.ends_,this.stride,e,t,s))}getCoordinates(){return bt(this.flatCoordinates,0,this.ends_,this.stride)}getEnds(){return this.ends_}getLineString(e){return e<0||this.ends_.length<=e?null:new v(this.flatCoordinates.slice(e===0?0:this.ends_[e-1],this.ends_[e]),this.layout)}getLineStrings(){const e=this.flatCoordinates,t=this.ends_,s=this.layout,i=[];let n=0;for(let r=0,o=t.length;r<o;++r){const a=t[r],h=new v(e.slice(n,a),s);i.push(h),n=a}return i}getLength(){const e=this.ends_;let t=0,s=0;for(let i=0,n=e.length;i<n;++i)s+=ct(this.flatCoordinates,t,e[i],this.stride),t=e[i];return s}getFlatMidpoints(){const e=[],t=this.flatCoordinates;let s=0;const i=this.ends_,n=this.stride;for(let r=0,o=i.length;r<o;++r){const a=i[r],h=dt(t,s,a,n,.5);L(e,h),s=a}return e}getSimplifiedGeometryInternal(e){const t=[],s=[];return t.length=Vt(this.flatCoordinates,0,this.ends_,this.stride,e,t,0,s),new H(t,"XY",s)}getType(){return"MultiLineString"}intersectsExtent(e){return Ot(this.flatCoordinates,0,this.ends_,this.stride,e)}setCoordinates(e,t){this.setLayout(t,e,2),this.flatCoordinates||(this.flatCoordinates=[]);const s=Nt(this.flatCoordinates,0,e,this.stride,this.ends_);this.flatCoordinates.length=s.length===0?0:s[s.length-1],this.changed()}}class ye extends ${constructor(e,t){super(),t&&!Array.isArray(e[0])?this.setFlatCoordinates(t,e):this.setCoordinates(e,t)}appendPoint(e){L(this.flatCoordinates,e.getFlatCoordinates()),this.changed()}clone(){const e=new ye(this.flatCoordinates.slice(),this.layout);return e.applyProperties(this),e}closestPointXY(e,t,s,i){if(i<z(this.getExtent(),e,t))return i;const n=this.flatCoordinates,r=this.stride;for(let o=0,a=n.length;o<a;o+=r){const h=Ge(e,t,n[o],n[o+1]);if(h<i){i=h;for(let d=0;d<r;++d)s[d]=n[o+d];s.length=r}}return i}getCoordinates(){return st(this.flatCoordinates,0,this.flatCoordinates.length,this.stride)}getPoint(e){const t=this.flatCoordinates.length/this.stride;return e<0||t<=e?null:new A(this.flatCoordinates.slice(e*this.stride,(e+1)*this.stride),this.layout)}getPoints(){const e=this.flatCoordinates,t=this.layout,s=this.stride,i=[];for(let n=0,r=e.length;n<r;n+=s){const o=new A(e.slice(n,n+s),t);i.push(o)}return i}getType(){return"MultiPoint"}intersectsExtent(e){const t=this.flatCoordinates,s=this.stride;for(let i=0,n=t.length;i<n;i+=s){const r=t[i],o=t[i+1];if(jt(e,r,o))return!0}return!1}setCoordinates(e,t){this.setLayout(t,e,1),this.flatCoordinates||(this.flatCoordinates=[]),this.flatCoordinates.length=it(this.flatCoordinates,0,e,this.stride),this.changed()}}class W extends ${constructor(e,t,s){if(super(),this.endss_=[],this.flatInteriorPointsRevision_=-1,this.flatInteriorPoints_=null,this.maxDelta_=-1,this.maxDeltaRevision_=-1,this.orientedRevision_=-1,this.orientedFlatCoordinates_=null,!s&&!Array.isArray(e[0])){const i=e,n=[],r=[];for(let o=0,a=i.length;o<a;++o){const h=i[o],d=n.length,u=h.getEnds();for(let c=0,g=u.length;c<g;++c)u[c]+=d;L(n,h.getFlatCoordinates()),r.push(u)}t=i.length===0?this.getLayout():i[0].getLayout(),e=n,s=r}t!==void 0&&s?(this.setFlatCoordinates(t,e),this.endss_=s):this.setCoordinates(e,t)}appendPolygon(e){let t;if(!this.flatCoordinates)this.flatCoordinates=e.getFlatCoordinates().slice(),t=e.getEnds().slice(),this.endss_.push();else{const s=this.flatCoordinates.length;L(this.flatCoordinates,e.getFlatCoordinates()),t=e.getEnds().slice();for(let i=0,n=t.length;i<n;++i)t[i]+=s}this.endss_.push(t),this.changed()}clone(){const e=this.endss_.length,t=new Array(e);for(let i=0;i<e;++i)t[i]=this.endss_[i].slice();const s=new W(this.flatCoordinates.slice(),this.layout,t);return s.applyProperties(this),s}closestPointXY(e,t,s,i){return i<z(this.getExtent(),e,t)?i:(this.maxDeltaRevision_!=this.getRevision()&&(this.maxDelta_=Math.sqrt(Ut(this.flatCoordinates,0,this.endss_,this.stride,0)),this.maxDeltaRevision_=this.getRevision()),Bt(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride,this.maxDelta_,!0,e,t,s,i))}containsXY(e,t){return Kt(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride,e,t)}getArea(){return qt(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride)}getCoordinates(e){let t;return e!==void 0?(t=this.getOrientedFlatCoordinates().slice(),be(t,0,this.endss_,this.stride,e)):t=this.flatCoordinates,Xt(t,0,this.endss_,this.stride)}getEndss(){return this.endss_}getFlatInteriorPoints(){if(this.flatInteriorPointsRevision_!=this.getRevision()){const e=Ps(this.flatCoordinates,0,this.endss_,this.stride);this.flatInteriorPoints_=Yt(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride,e),this.flatInteriorPointsRevision_=this.getRevision()}return this.flatInteriorPoints_}getInteriorPoints(){return new ye(this.getFlatInteriorPoints().slice(),"XYM")}getOrientedFlatCoordinates(){if(this.orientedRevision_!=this.getRevision()){const e=this.flatCoordinates;Ht(e,0,this.endss_,this.stride)?this.orientedFlatCoordinates_=e:(this.orientedFlatCoordinates_=e.slice(),this.orientedFlatCoordinates_.length=be(this.orientedFlatCoordinates_,0,this.endss_,this.stride)),this.orientedRevision_=this.getRevision()}return this.orientedFlatCoordinates_}getSimplifiedGeometryInternal(e){const t=[],s=[];return t.length=Wt(this.flatCoordinates,0,this.endss_,this.stride,Math.sqrt(e),t,0,s),new W(t,"XY",s)}getPolygon(e){if(e<0||this.endss_.length<=e)return null;let t;if(e===0)t=0;else{const n=this.endss_[e-1];t=n[n.length-1]}const s=this.endss_[e].slice(),i=s[s.length-1];if(t!==0)for(let n=0,r=s.length;n<r;++n)s[n]-=t;return new ae(this.flatCoordinates.slice(t,i),this.layout,s)}getPolygons(){const e=this.layout,t=this.flatCoordinates,s=this.endss_,i=[];let n=0;for(let r=0,o=s.length;r<o;++r){const a=s[r].slice(),h=a[a.length-1];if(n!==0)for(let u=0,c=a.length;u<c;++u)a[u]-=n;const d=new ae(t.slice(n,h),e,a);i.push(d),n=h}return i}getType(){return"MultiPolygon"}intersectsExtent(e){return $t(this.getOrientedFlatCoordinates(),0,this.endss_,this.stride,e)}setCoordinates(e,t){this.setLayout(t,e,3),this.flatCoordinates||(this.flatCoordinates=[]);const s=zt(this.flatCoordinates,0,e,this.stride,this.endss_);if(s.length===0)this.flatCoordinates.length=0;else{const i=s[s.length-1];this.flatCoordinates.length=i.length===0?0:i[i.length-1]}this.changed()}}function k(l,e){const t=l.length;return e<0?l[e+t]:e>=t?l[e-t]:l[e]}function V(l,e){const t=l.length;let s=Math.floor(e);const i=e-s;s>=t?s-=t:s<0&&(s+=t);let n=s+1;n>=t&&(n-=t);const r=l[s],o=r[0],a=r[1],h=l[n],d=h[0]-o,u=h[1]-a;return[o+d*i,a+u*i]}const J={index:-1,endIndex:NaN,closestTargetDistance:1/0};function ft(l,e,t,s){const i=l[0],n=l[1];let r=1/0,o=-1,a=NaN;for(let u=0;u<e.targets.length;++u){const c=e.targets[u],g=c.coordinates;let f=1/0,_;for(let m=0;m<g.length-1;++m){const y=g[m],x=g[m+1],F=yt(i,n,y,x);F.squaredDistance<f&&(f=F.squaredDistance,_=m+F.along)}f<r&&(r=f,c.ring&&e.targetIndex===u&&(c.endIndex>c.startIndex?_<c.startIndex&&(_+=g.length):c.endIndex<c.startIndex&&_>c.startIndex&&(_-=g.length)),a=_,o=u)}const h=e.targets[o];let d=h.ring;if(e.targetIndex===o&&d){const u=V(h.coordinates,a),c=t.getPixelFromCoordinate(u),g=t.getPixelFromCoordinate(e.startCoord);b(c,g)>s&&(d=!1)}if(d){const u=h.coordinates,c=u.length,g=h.startIndex,f=a;if(g<f){const _=te(u,g,f);te(u,g,f-c)<_&&(a-=c)}else{const _=te(u,g,f);te(u,g,f+c)<_&&(a+=c)}}return J.index=o,J.endIndex=a,J.closestTargetDistance=r,J}function _t(l,e){const t=[];for(let s=0;s<e.length;++s){const n=e[s].getGeometry();mt(l,n,t)}return t}function mt(l,e,t){if(e instanceof v){Q(l,e.getCoordinates(),!1,t);return}if(e instanceof H){const s=e.getCoordinates();for(let i=0,n=s.length;i<n;++i)Q(l,s[i],!1,t);return}if(e instanceof ae){const s=e.getCoordinates();for(let i=0,n=s.length;i<n;++i)Q(l,s[i],!0,t);return}if(e instanceof W){const s=e.getCoordinates();for(let i=0,n=s.length;i<n;++i){const r=s[i];for(let o=0,a=r.length;o<a;++o)Q(l,r[o],!0,t)}return}if(e instanceof ce){const s=e.getGeometries();for(let i=0;i<s.length;++i)mt(l,s[i],t);return}}function Q(l,e,t,s){const i=l[0],n=l[1];for(let r=0,o=e.length-1;r<o;++r){const a=e[r],h=e[r+1],d=yt(i,n,a,h);if(d.squaredDistance===0){const u=r+d.along;s.push({coordinates:e,ring:t,startIndex:u,endIndex:u});return}}}function ee(l,e){return Ge(l[0],l[1],e[0],e[1])}function te(l,e,t){let s,i;e<t?(s=e,i=t):(s=t,i=e);const n=Math.ceil(s),r=Math.floor(i);if(n>r){const a=V(l,s),h=V(l,i);return ee(a,h)}let o=0;if(s<n){const a=V(l,s),h=k(l,n);o+=ee(a,h)}if(r<i){const a=k(l,r),h=V(l,i);o+=ee(a,h)}for(let a=n;a<r-1;++a){const h=k(l,a),d=k(l,a+1);o+=ee(h,d)}return o}const xe={along:0,squaredDistance:0};function yt(l,e,t,s){const i=t[0],n=t[1],r=s[0],o=s[1],a=r-i,h=o-n;let d=0,u=i,c=n;return(a!==0||h!==0)&&(d=Jt(((l-i)*a+(e-n)*h)/(a*a+h*h),0,1),u+=a*d,c+=h*d),xe.along=d,xe.squaredDistance=Zt(Ge(l,e,u,c),10),xe}const se={DRAWSTART:"drawstart",DRAWEND:"drawend",DRAWABORT:"drawabort"};class ie extends _e{constructor(e,t){super(e),this.feature=t}}class Ke extends fe{constructor(e){const t=e;t.stopDown||(t.stopDown=nt),super(t),this.on,this.once,this.un,this.options_=e,this.shouldHandle_=!1,this.downPx_=null,this.downTimeout_,this.lastDragTime_,this.pointerType_,this.freehand_=!1,this.source_=e.source?e.source:null,this.features_=e.features?e.features:null,this.snapTolerance_=e.snapTolerance?e.snapTolerance:12,this.type_=e.type,this.mode_=Ms(this.type_),this.stopClick_=!!e.stopClick,this.ignoreNextUpEvent_=!1,this.minPoints_=e.minPoints?e.minPoints:this.mode_==="Polygon"?3:2,this.maxPoints_=this.mode_==="Circle"?2:e.maxPoints?e.maxPoints:1/0,this.finishCondition_=e.finishCondition?e.finishCondition:he,this.geometryLayout_=e.geometryLayout?e.geometryLayout:"XY";let s=e.geometryFunction;if(!s){const i=this.mode_;if(i==="Circle")s=(n,r,o)=>{const a=r||new me([NaN,NaN]),h=p(n[0]),d=I(h,p(n[n.length-1]));return a.setCenterAndRadius(h,Math.sqrt(d),this.geometryLayout_),a};else{let n;i==="Point"?n=A:i==="LineString"?n=v:i==="Polygon"&&(n=ae),s=(r,o,a)=>(o?i==="Polygon"?r[0].length?o.setCoordinates([r[0].concat([r[0][0]])],this.geometryLayout_):o.setCoordinates([],this.geometryLayout_):o.setCoordinates(r,this.geometryLayout_):o=new n(r,this.geometryLayout_),o)}}this.geometryFunction_=s,this.dragVertexDelay_=e.dragVertexDelay!==void 0?e.dragVertexDelay:500,this.finishCoordinate_=null,this.sketchFeature_=null,this.sketchPoint_=null,this.sketchCoords_=null,this.sketchLine_=null,this.sketchLineCoords_=null,this.squaredClickTolerance_=e.clickTolerance?e.clickTolerance*e.clickTolerance:36,this.overlay_=new Ae({source:new Ie({useSpatialIndex:!1,wrapX:e.wrapX?e.wrapX:!1}),style:e.style?e.style:vs(),updateWhileInteracting:!0}),this.geometryName_=e.geometryName,this.condition_=e.condition?e.condition:Qt,this.freehandCondition_,e.freehand?this.freehandCondition_=O:this.freehandCondition_=e.freehandCondition?e.freehandCondition:Ve,this.traceCondition_,this.setTrace(e.trace||!1),this.traceState_={active:!1},this.traceSource_=e.traceSource||e.source||null,this.addChangeListener(rt.ACTIVE,this.updateState_)}setTrace(e){let t;e?e===!0?t=O:t=e:t=ot,this.traceCondition_=t}setMap(e){super.setMap(e),this.updateState_()}setFreehand(e){this.freehand_=e,this.freehand_?this.freehandCondition_=O:this.freehandCondition_=this.options_&&this.options_.freehandCondition?this.options_.freehandCondition:Ve}getOverlay(){return this.overlay_}getFreehand(){return this.freehand_}handleEvent(e){e.originalEvent.type===X.CONTEXTMENU&&e.originalEvent.preventDefault(),this.freehand_=this.mode_!=="Point"&&this.freehandCondition_(e);let t=e.type===T.POINTERMOVE,s=!0;return!this.freehand_&&this.lastDragTime_&&e.type===T.POINTERDRAG&&(Date.now()-this.lastDragTime_>=this.dragVertexDelay_?(this.downPx_=e.pixel,this.shouldHandle_=!this.freehand_,t=!0):this.lastDragTime_=void 0,this.shouldHandle_&&this.downTimeout_!==void 0&&(clearTimeout(this.downTimeout_),this.downTimeout_=void 0)),this.freehand_&&e.type===T.POINTERDRAG&&this.sketchFeature_!==null?(this.addToDrawing_(e.coordinate),s=!1):this.freehand_&&e.type===T.POINTERDOWN?s=!1:t&&this.getPointerCount()<2?(s=e.type===T.POINTERMOVE,s&&this.freehand_?(this.handlePointerMove_(e),this.shouldHandle_&&e.originalEvent.preventDefault()):(e.originalEvent.pointerType==="mouse"||e.type===T.POINTERDRAG&&this.downTimeout_===void 0)&&this.handlePointerMove_(e)):e.type===T.DBLCLICK&&(s=!1),super.handleEvent(e)&&s}handleDownEvent(e){return this.shouldHandle_=!this.freehand_,this.freehand_?(this.downPx_=e.pixel,this.finishCoordinate_||this.startDrawing_(e.coordinate),!0):this.condition_(e)?(this.lastDragTime_=Date.now(),this.downTimeout_=setTimeout(()=>{this.handlePointerMove_(new es(T.POINTERMOVE,e.map,e.originalEvent,!1,e.frameState))},this.dragVertexDelay_),this.downPx_=e.pixel,!0):(this.lastDragTime_=void 0,!1)}deactivateTrace_(){this.traceState_={active:!1}}toggleTraceState_(e){if(!this.traceSource_||!this.traceCondition_(e))return;if(this.traceState_.active){this.deactivateTrace_();return}const t=this.getMap(),s=t.getCoordinateFromPixel([e.pixel[0]-this.snapTolerance_,e.pixel[1]+this.snapTolerance_]),i=t.getCoordinateFromPixel([e.pixel[0]+this.snapTolerance_,e.pixel[1]-this.snapTolerance_]),n=C([s,i]),r=this.traceSource_.getFeaturesInExtent(n);if(r.length===0)return;const o=_t(e.coordinate,r);o.length&&(this.traceState_={active:!0,startCoord:e.coordinate.slice(),targets:o,targetIndex:-1})}addOrRemoveTracedCoordinates_(e,t){const s=e.startIndex<=e.endIndex,i=e.startIndex<=t;s===i?s&&t>e.endIndex||!s&&t<e.endIndex?this.addTracedCoordinates_(e,e.endIndex,t):(s&&t<e.endIndex||!s&&t>e.endIndex)&&this.removeTracedCoordinates_(t,e.endIndex):(this.removeTracedCoordinates_(e.startIndex,e.endIndex),this.addTracedCoordinates_(e,e.startIndex,t))}removeTracedCoordinates_(e,t){if(e===t)return;let s=0;if(e<t){const i=Math.ceil(e);let n=Math.floor(t);n===t&&(n-=1),s=n-i+1}else{const i=Math.floor(e);let n=Math.ceil(t);n===t&&(n+=1),s=i-n+1}s>0&&this.removeLastPoints_(s)}addTracedCoordinates_(e,t,s){if(t===s)return;const i=[];if(t<s){const n=Math.ceil(t);let r=Math.floor(s);r===s&&(r-=1);for(let o=n;o<=r;++o)i.push(k(e.coordinates,o))}else{const n=Math.floor(t);let r=Math.ceil(s);r===s&&(r+=1);for(let o=n;o>=r;--o)i.push(k(e.coordinates,o))}i.length&&this.appendCoordinates(i)}updateTrace_(e){const t=this.traceState_;if(!t.active)return;if(t.targetIndex===-1){const o=e.map.getPixelFromCoordinate(t.startCoord);if(b(o,e.pixel)<this.snapTolerance_)return}const s=ft(e.coordinate,t,this.getMap(),this.snapTolerance_);if(t.targetIndex!==s.index){if(t.targetIndex!==-1){const a=t.targets[t.targetIndex];this.removeTracedCoordinates_(a.startIndex,a.endIndex)}const o=t.targets[s.index];this.addTracedCoordinates_(o,o.startIndex,s.endIndex)}else{const o=t.targets[t.targetIndex];this.addOrRemoveTracedCoordinates_(o,s.endIndex)}t.targetIndex=s.index;const i=t.targets[t.targetIndex];i.endIndex=s.endIndex;const n=V(i.coordinates,i.endIndex),r=this.getMap().getPixelFromCoordinate(n);e.coordinate=n,e.pixel=[Math.round(r[0]),Math.round(r[1])]}handleDragEvent(e){this.ignoreNextUpEvent_=!0,super.handleDragEvent(e)}handleUpEvent(e){let t=!0;if(this.getPointerCount()===0){this.downTimeout_&&(clearTimeout(this.downTimeout_),this.downTimeout_=void 0),this.handlePointerMove_(e);const s=this.traceState_.active;if(this.ignoreNextUpEvent_||this.toggleTraceState_(e),this.shouldHandle_){const i=!this.finishCoordinate_;i&&this.startDrawing_(e.coordinate),!i&&this.freehand_?this.finishDrawing():!this.freehand_&&(!i||this.mode_==="Point")&&(this.atFinish_(e.pixel,s)?this.finishCondition_(e)&&this.finishDrawing():this.addToDrawing_(e.coordinate)),t=!1}else this.freehand_&&this.abortDrawing()}return this.ignoreNextUpEvent_=!1,!t&&this.stopClick_&&e.preventDefault(),t}handlePointerMove_(e){if(this.pointerType_=e.originalEvent.pointerType,this.downPx_&&(!this.freehand_&&this.shouldHandle_||this.freehand_&&!this.shouldHandle_)){const t=this.downPx_,s=e.pixel,i=t[0]-s[0],n=t[1]-s[1],r=i*i+n*n;if(this.shouldHandle_=this.freehand_?r>this.squaredClickTolerance_:r<=this.squaredClickTolerance_,!this.shouldHandle_)return}if(!this.finishCoordinate_){this.createOrUpdateSketchPoint_(e.coordinate.slice());return}this.updateTrace_(e),this.modifyDrawing_(e.coordinate)}atFinish_(e,t){let s=!1;if(this.sketchFeature_){let i=!1,n=[this.finishCoordinate_];const r=this.mode_;if(r==="Point")s=!0;else if(r==="Circle")s=this.sketchCoords_.length===2;else if(r==="LineString")i=!t&&this.sketchCoords_.length>this.minPoints_;else if(r==="Polygon"){const o=this.sketchCoords_;i=o[0].length>this.minPoints_,n=[o[0][0],o[0][o[0].length-2]],t?n=[o[0][0]]:n=[o[0][0],o[0][o[0].length-2]]}if(i){const o=this.getMap();for(let a=0,h=n.length;a<h;a++){const d=n[a],u=o.getPixelFromCoordinate(d),c=e[0]-u[0],g=e[1]-u[1],f=this.freehand_?1:this.snapTolerance_;if(s=Math.sqrt(c*c+g*g)<=f,s){this.finishCoordinate_=d;break}}}}return s}createOrUpdateSketchPoint_(e){this.sketchPoint_?this.sketchPoint_.getGeometry().setCoordinates(e):(this.sketchPoint_=new E(new A(e)),this.updateSketchFeatures_())}createOrUpdateCustomSketchLine_(e){this.sketchLine_||(this.sketchLine_=new E);const t=e.getLinearRing(0);let s=this.sketchLine_.getGeometry();s?(s.setFlatCoordinates(t.getLayout(),t.getFlatCoordinates()),s.changed()):(s=new v(t.getFlatCoordinates(),t.getLayout()),this.sketchLine_.setGeometry(s))}startDrawing_(e){const t=this.getMap().getView().getProjection(),s=Oe(this.geometryLayout_);for(;e.length<s;)e.push(0);this.finishCoordinate_=e,this.mode_==="Point"?this.sketchCoords_=e.slice():this.mode_==="Polygon"?(this.sketchCoords_=[[e.slice(),e.slice()]],this.sketchLineCoords_=this.sketchCoords_[0]):this.sketchCoords_=[e.slice(),e.slice()],this.sketchLineCoords_&&(this.sketchLine_=new E(new v(this.sketchLineCoords_)));const i=this.geometryFunction_(this.sketchCoords_,void 0,t);this.sketchFeature_=new E,this.geometryName_&&this.sketchFeature_.setGeometryName(this.geometryName_),this.sketchFeature_.setGeometry(i),this.updateSketchFeatures_(),this.dispatchEvent(new ie(se.DRAWSTART,this.sketchFeature_))}modifyDrawing_(e){const t=this.getMap(),s=this.sketchFeature_.getGeometry(),i=t.getView().getProjection(),n=Oe(this.geometryLayout_);let r,o;for(;e.length<n;)e.push(0);this.mode_==="Point"?o=this.sketchCoords_:this.mode_==="Polygon"?(r=this.sketchCoords_[0],o=r[r.length-1],this.atFinish_(t.getPixelFromCoordinate(e))&&(e=this.finishCoordinate_.slice())):(r=this.sketchCoords_,o=r[r.length-1]),o[0]=e[0],o[1]=e[1],this.geometryFunction_(this.sketchCoords_,s,i),this.sketchPoint_&&this.sketchPoint_.getGeometry().setCoordinates(e),s.getType()==="Polygon"&&this.mode_!=="Polygon"?this.createOrUpdateCustomSketchLine_(s):this.sketchLineCoords_&&this.sketchLine_.getGeometry().setCoordinates(this.sketchLineCoords_),this.updateSketchFeatures_()}addToDrawing_(e){const t=this.sketchFeature_.getGeometry(),s=this.getMap().getView().getProjection();let i,n;const r=this.mode_;return r==="LineString"||r==="Circle"?(this.finishCoordinate_=e.slice(),n=this.sketchCoords_,n.length>=this.maxPoints_&&(this.freehand_?n.pop():i=!0),n.push(e.slice()),this.geometryFunction_(n,t,s)):r==="Polygon"&&(n=this.sketchCoords_[0],n.length>=this.maxPoints_&&(this.freehand_?n.pop():i=!0),n.push(e.slice()),i&&(this.finishCoordinate_=n[0]),this.geometryFunction_(this.sketchCoords_,t,s)),this.createOrUpdateSketchPoint_(e.slice()),this.updateSketchFeatures_(),i?this.finishDrawing():this.sketchFeature_}removeLastPoints_(e){if(!this.sketchFeature_)return;const t=this.sketchFeature_.getGeometry(),s=this.getMap().getView().getProjection(),i=this.mode_;for(let n=0;n<e;++n){let r;if(i==="LineString"||i==="Circle"){if(r=this.sketchCoords_,r.splice(-2,1),r.length>=2){this.finishCoordinate_=r[r.length-2].slice();const o=this.finishCoordinate_.slice();r[r.length-1]=o,this.createOrUpdateSketchPoint_(o)}this.geometryFunction_(r,t,s),t.getType()==="Polygon"&&this.sketchLine_&&this.createOrUpdateCustomSketchLine_(t)}else if(i==="Polygon"){r=this.sketchCoords_[0],r.splice(-2,1);const o=this.sketchLine_.getGeometry();if(r.length>=2){const a=r[r.length-2].slice();r[r.length-1]=a,this.createOrUpdateSketchPoint_(a)}o.setCoordinates(r),this.geometryFunction_(this.sketchCoords_,t,s)}if(r.length===1){this.abortDrawing();break}}this.updateSketchFeatures_()}removeLastPoint(){this.removeLastPoints_(1)}finishDrawing(){const e=this.abortDrawing_();if(!e)return null;let t=this.sketchCoords_;const s=e.getGeometry(),i=this.getMap().getView().getProjection();return this.mode_==="LineString"?(t.pop(),this.geometryFunction_(t,s,i)):this.mode_==="Polygon"&&(t[0].pop(),this.geometryFunction_(t,s,i),t=s.getCoordinates()),this.type_==="MultiPoint"?e.setGeometry(new ye([t])):this.type_==="MultiLineString"?e.setGeometry(new H([t])):this.type_==="MultiPolygon"&&e.setGeometry(new W([t])),this.dispatchEvent(new ie(se.DRAWEND,e)),this.features_&&this.features_.push(e),this.source_&&this.source_.addFeature(e),e}abortDrawing_(){this.finishCoordinate_=null;const e=this.sketchFeature_;return this.sketchFeature_=null,this.sketchPoint_=null,this.sketchLine_=null,this.overlay_.getSource().clear(!0),this.deactivateTrace_(),e}abortDrawing(){const e=this.abortDrawing_();e&&this.dispatchEvent(new ie(se.DRAWABORT,e))}appendCoordinates(e){const t=this.mode_,s=!this.sketchFeature_;s&&this.startDrawing_(e[0]);let i;if(t==="LineString"||t==="Circle")i=this.sketchCoords_;else if(t==="Polygon")i=this.sketchCoords_&&this.sketchCoords_.length?this.sketchCoords_[0]:[];else return;s&&i.shift(),i.pop();for(let r=0;r<e.length;r++)this.addToDrawing_(e[r]);const n=e[e.length-1];this.sketchFeature_=this.addToDrawing_(n),this.modifyDrawing_(n)}extend(e){const s=e.getGeometry();this.sketchFeature_=e,this.sketchCoords_=s.getCoordinates();const i=this.sketchCoords_[this.sketchCoords_.length-1];this.finishCoordinate_=i.slice(),this.sketchCoords_.push(i.slice()),this.sketchPoint_=new E(new A(i)),this.updateSketchFeatures_(),this.dispatchEvent(new ie(se.DRAWSTART,this.sketchFeature_))}updateSketchFeatures_(){const e=[];this.sketchFeature_&&e.push(this.sketchFeature_),this.sketchLine_&&e.push(this.sketchLine_),this.sketchPoint_&&e.push(this.sketchPoint_);const t=this.overlay_.getSource();t.clear(!0),t.addFeatures(e)}updateState_(){const e=this.getMap(),t=this.getActive();(!e||!t)&&this.abortDrawing(),this.overlay_.setMap(t?e:null)}}function vs(){const l=at();return function(e,t){return l[e.getGeometry().getType()]}}function Ms(l){switch(l){case"Point":case"MultiPoint":return"Point";case"LineString":case"MultiLineString":return"LineString";case"Polygon":case"MultiPolygon":return"Polygon";case"Circle":return"Circle";default:throw new Error("Invalid type: "+l)}}const Te={TRANSLATESTART:"translatestart",TRANSLATING:"translating",TRANSLATEEND:"translateend"};class Fe extends _e{constructor(e,t,s,i,n){super(e),this.features=t,this.coordinate=s,this.startCoordinate=i,this.mapBrowserEvent=n}}class ks extends fe{constructor(e){e=e||{},super(e),this.on,this.once,this.un,this.lastCoordinate_=null,this.startCoordinate_=null,this.features_=e.features!==void 0?e.features:null;let t;if(e.layers&&!this.features_)if(typeof e.layers=="function")t=e.layers;else{const s=e.layers;t=function(i){return s.includes(i)}}else t=he;this.layerFilter_=t,this.filter_=e.filter&&!this.features_?e.filter:he,this.hitTolerance_=e.hitTolerance?e.hitTolerance:0,this.condition_=e.condition?e.condition:O,this.lastFeature_=null,this.addChangeListener(rt.ACTIVE,this.handleActiveChanged_)}handleDownEvent(e){if(!e.originalEvent||!this.condition_(e))return!1;if(this.lastFeature_=this.featuresAtPixel_(e.pixel,e.map),!this.lastCoordinate_&&this.lastFeature_){this.startCoordinate_=e.coordinate,this.lastCoordinate_=e.coordinate,this.handleMoveEvent(e);const t=this.features_||new N([this.lastFeature_]);return this.dispatchEvent(new Fe(Te.TRANSLATESTART,t,e.coordinate,this.startCoordinate_,e)),!0}return!1}handleUpEvent(e){if(this.lastCoordinate_){this.lastCoordinate_=null,this.handleMoveEvent(e);const t=this.features_||new N([this.lastFeature_]);return this.dispatchEvent(new Fe(Te.TRANSLATEEND,t,e.coordinate,this.startCoordinate_,e)),this.startCoordinate_=null,!0}return!1}handleDragEvent(e){if(this.lastCoordinate_){const t=e.coordinate;e.map.getView().getProjection();const s=p(t),i=p(this.lastCoordinate_),n=s[0]-i[0],r=s[1]-i[1],o=this.features_||new N([this.lastFeature_]);o.forEach(function(a){const h=a.getGeometry();h.translate(n,r),a.setGeometry(h)}),this.lastCoordinate_=t,this.dispatchEvent(new Fe(Te.TRANSLATING,o,t,this.startCoordinate_,e))}}handleMoveEvent(e){const t=e.map.getViewport();this.featuresAtPixel_(e.pixel,e.map)?(t.classList.remove(this.lastCoordinate_?"ol-grab":"ol-grabbing"),t.classList.add(this.lastCoordinate_?"ol-grabbing":"ol-grab")):t.classList.remove("ol-grab","ol-grabbing")}featuresAtPixel_(e,t){return t.forEachFeatureAtPixel(e,(s,i)=>{if(!(!(s instanceof E)||!this.filter_(s,i))&&!(this.features_&&!this.features_.getArray().includes(s)))return s},{layerFilter:this.layerFilter_,hitTolerance:this.hitTolerance_})}getHitTolerance(){return this.hitTolerance_}setHitTolerance(e){this.hitTolerance_=e}setMap(e){const t=this.getMap();super.setMap(e),this.updateState_(t)}handleActiveChanged_(){this.updateState_(null)}updateState_(e){let t=this.getMap();const s=this.getActive();(!t||!s)&&(t=t||e,t&&t.getViewport().classList.remove("ol-grab","ol-grabbing"))}}const qe=0,q=1,Xe=[0,0,0,0],j=[],we={MODIFYSTART:"modifystart",MODIFYEND:"modifyend"};function Se(l,e,t){let s;switch(e){case"LineString":s=l;break;case"MultiLineString":case"Polygon":s=l[t[0]];break;case"MultiPolygon":s=l[t[1]][t[0]];break}return s}class Pe extends _e{constructor(e,t,s){super(e),this.features=t,this.mapBrowserEvent=s}}class Ds extends fe{constructor(e){super(e),this.on,this.once,this.un,this.boundHandleFeatureChange_=this.handleFeatureChange_.bind(this),this.condition_=e.condition?e.condition:ts,this.defaultDeleteCondition_=function(s){return ss(s)&&is(s)},this.deleteCondition_=e.deleteCondition?e.deleteCondition:this.defaultDeleteCondition_,this.insertVertexCondition_=e.insertVertexCondition?e.insertVertexCondition:O,this.vertexFeature_=null,this.vertexSegments_=null,this.lastCoordinate_=[0,0],this.ignoreNextSingleClick_=!1,this.featuresBeingModified_=null,this.rBush_=new ut,this.pixelTolerance_=e.pixelTolerance!==void 0?e.pixelTolerance:10,this.snappedToVertex_=!1,this.changingFeature_=!1,this.dragSegments_=[],this.overlay_=new Ae({source:new Ie({useSpatialIndex:!1,wrapX:!!e.wrapX}),style:e.style?e.style:Ls(),updateWhileAnimating:!0,updateWhileInteracting:!0}),this.SEGMENT_WRITERS_={Point:this.writePointGeometry_.bind(this),LineString:this.writeLineStringGeometry_.bind(this),LinearRing:this.writeLineStringGeometry_.bind(this),Polygon:this.writePolygonGeometry_.bind(this),MultiPoint:this.writeMultiPointGeometry_.bind(this),MultiLineString:this.writeMultiLineStringGeometry_.bind(this),MultiPolygon:this.writeMultiPolygonGeometry_.bind(this),Circle:this.writeCircleGeometry_.bind(this),GeometryCollection:this.writeGeometryCollectionGeometry_.bind(this)},this.source_=null,this.traceSource_=e.traceSource||e.source||null,this.traceCondition_,this.setTrace(e.trace||!1),this.traceState_={active:!1},this.traceSegments_=null,this.hitDetection_=null;let t;if(e.features?t=e.features:e.source&&(this.source_=e.source,t=new N(this.source_.getFeatures()),this.source_.addEventListener(de.ADDFEATURE,this.handleSourceAdd_.bind(this)),this.source_.addEventListener(de.REMOVEFEATURE,this.handleSourceRemove_.bind(this))),!t)throw new Error("The modify interaction requires features, a source or a layer");e.hitDetection&&(this.hitDetection_=e.hitDetection),this.features_=t,this.features_.forEach(this.addFeature_.bind(this)),this.features_.addEventListener(le.ADD,this.handleFeatureAdd_.bind(this)),this.features_.addEventListener(le.REMOVE,this.handleFeatureRemove_.bind(this)),this.lastPointerEvent_=null,this.delta_=[0,0],this.snapToPointer_=e.snapToPointer===void 0?!this.hitDetection_:e.snapToPointer}setTrace(e){let t;e?e===!0?t=O:t=e:t=ot,this.traceCondition_=t}addFeature_(e){const t=e.getGeometry();if(t){const i=this.SEGMENT_WRITERS_[t.getType()];i&&i(e,t)}const s=this.getMap();s&&s.isRendered()&&this.getActive()&&this.handlePointerAtPixel_(this.lastCoordinate_),e.addEventListener(X.CHANGE,this.boundHandleFeatureChange_)}willModifyFeatures_(e,t){if(!this.featuresBeingModified_){this.featuresBeingModified_=new N;const s=this.featuresBeingModified_.getArray();for(let i=0,n=t.length;i<n;++i){const r=t[i].feature;r&&!s.includes(r)&&this.featuresBeingModified_.push(r)}this.featuresBeingModified_.getLength()===0?this.featuresBeingModified_=null:this.dispatchEvent(new Pe(we.MODIFYSTART,this.featuresBeingModified_,e))}}removeFeature_(e){this.removeFeatureSegmentData_(e),this.vertexFeature_&&this.features_.getLength()===0&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null),e.removeEventListener(X.CHANGE,this.boundHandleFeatureChange_)}removeFeatureSegmentData_(e){const t=this.rBush_,s=[];t.forEach(function(i){e===i.feature&&s.push(i)});for(let i=s.length-1;i>=0;--i){const n=s[i];for(let r=this.dragSegments_.length-1;r>=0;--r)this.dragSegments_[r][0]===n&&this.dragSegments_.splice(r,1);t.remove(n)}}setActive(e){this.vertexFeature_&&!e&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null),super.setActive(e)}setMap(e){this.overlay_.setMap(e),super.setMap(e)}getOverlay(){return this.overlay_}handleSourceAdd_(e){e.feature&&this.features_.push(e.feature)}handleSourceRemove_(e){e.feature&&this.features_.remove(e.feature)}handleFeatureAdd_(e){this.addFeature_(e.element)}handleFeatureChange_(e){if(!this.changingFeature_){const t=e.target;this.removeFeature_(t),this.addFeature_(t)}}handleFeatureRemove_(e){this.removeFeature_(e.element)}writePointGeometry_(e,t){const s=t.getCoordinates(),i={feature:e,geometry:t,segment:[s,s]};this.rBush_.insert(t.getExtent(),i)}writeMultiPointGeometry_(e,t){const s=t.getCoordinates();for(let i=0,n=s.length;i<n;++i){const r=s[i],o={feature:e,geometry:t,depth:[i],index:i,segment:[r,r]};this.rBush_.insert(t.getExtent(),o)}}writeLineStringGeometry_(e,t){const s=t.getCoordinates();for(let i=0,n=s.length-1;i<n;++i){const r=s.slice(i,i+2),o={feature:e,geometry:t,index:i,segment:r};this.rBush_.insert(C(r),o)}}writeMultiLineStringGeometry_(e,t){const s=t.getCoordinates();for(let i=0,n=s.length;i<n;++i){const r=s[i];for(let o=0,a=r.length-1;o<a;++o){const h=r.slice(o,o+2),d={feature:e,geometry:t,depth:[i],index:o,segment:h};this.rBush_.insert(C(h),d)}}}writePolygonGeometry_(e,t){const s=t.getCoordinates();for(let i=0,n=s.length;i<n;++i){const r=s[i];for(let o=0,a=r.length-1;o<a;++o){const h=r.slice(o,o+2),d={feature:e,geometry:t,depth:[i],index:o,segment:h};this.rBush_.insert(C(h),d)}}}writeMultiPolygonGeometry_(e,t){const s=t.getCoordinates();for(let i=0,n=s.length;i<n;++i){const r=s[i];for(let o=0,a=r.length;o<a;++o){const h=r[o];for(let d=0,u=h.length-1;d<u;++d){const c=h.slice(d,d+2),g={feature:e,geometry:t,depth:[o,i],index:d,segment:c};this.rBush_.insert(C(c),g)}}}}writeCircleGeometry_(e,t){const s=t.getCenter(),i={feature:e,geometry:t,index:qe,segment:[s,s]},n={feature:e,geometry:t,index:q,segment:[s,s]},r=[i,n];i.featureSegments=r,n.featureSegments=r,this.rBush_.insert(pe(s),i);let o=t;this.rBush_.insert(o.getExtent(),n)}writeGeometryCollectionGeometry_(e,t){const s=t.getGeometriesArray();for(let i=0;i<s.length;++i){const n=s[i],r=this.SEGMENT_WRITERS_[n.getType()];r(e,n)}}createOrUpdateVertexFeature_(e,t,s,i){let n=this.vertexFeature_;return n?n.getGeometry().setCoordinates(e):(n=new E(new A(e)),this.vertexFeature_=n,this.overlay_.getSource().addFeature(n)),n.set("features",t),n.set("geometries",s),n.set("existing",i),n}handleEvent(e){if(!e.originalEvent)return!0;this.lastPointerEvent_=e;let t;return!e.map.getView().getInteracting()&&e.type==T.POINTERMOVE&&!this.handlingDownUpSequence&&this.handlePointerMove_(e),this.vertexFeature_&&this.deleteCondition_(e)&&(e.type!=T.SINGLECLICK||!this.ignoreNextSingleClick_?t=this.removePoint():t=!0),e.type==T.SINGLECLICK&&(this.ignoreNextSingleClick_=!1),super.handleEvent(e)&&!t}findInsertVerticesAndUpdateDragSegments_(e){if(this.handlePointerAtPixel_(e),this.dragSegments_.length=0,this.featuresBeingModified_=null,!this.vertexFeature_)return;this.getMap().getView().getProjection();const s=[],i=this.vertexFeature_.getGeometry().getCoordinates(),n=C([i]),r=this.rBush_.getInExtent(n),o={};r.sort(Gs);for(let a=0,h=r.length;a<h;++a){const d=r[a],u=d.segment;let c=S(d.geometry);const g=d.depth;if(g&&(c+="-"+g.join("-")),o[c]||(o[c]=new Array(2)),d.geometry.getType()==="Circle"&&d.index===q){const f=He(e,d);w(f,i)&&!o[c][0]&&(this.dragSegments_.push([d,0]),o[c][0]=d);continue}if(w(u[0],i)&&!o[c][0]){this.dragSegments_.push([d,0]),o[c][0]=d;continue}if(w(u[1],i)&&!o[c][1]){if(o[c][0]&&o[c][0].index===0){let f=d.geometry.getCoordinates();switch(d.geometry.getType()){case"LineString":case"MultiLineString":continue;case"MultiPolygon":f=f[g[1]];case"Polygon":if(d.index!==f[g[0]].length-2)continue;break}}this.dragSegments_.push([d,1]),o[c][1]=d;continue}S(u)in this.vertexSegments_&&!o[c][0]&&!o[c][1]&&s.push(d)}return s}deactivateTrace_(){this.traceState_={active:!1}}updateTrace_(e){const t=this.traceState_;if(!t.active)return;if(t.targetIndex===-1){const n=e.map.getPixelFromCoordinate(t.startCoord);if(b(n,e.pixel)<this.pixelTolerance_)return}const s=ft(e.coordinate,t,e.map,this.pixelTolerance_);if(t.targetIndex===-1&&Math.sqrt(s.closestTargetDistance)/e.map.getView().getResolution()>this.pixelTolerance_)return;if(t.targetIndex!==s.index){if(t.targetIndex!==-1){const r=t.targets[t.targetIndex];this.removeTracedCoordinates_(r.startIndex,r.endIndex)}else for(const r of this.traceSegments_){const o=r[0],a=o.geometry,h=r[1],d=a.getCoordinates();Se(d,a.getType(),o.depth).splice(o.index+h,1),a.setCoordinates(d),h===0&&(o.index-=1)}const n=t.targets[s.index];this.addTracedCoordinates_(n,n.startIndex,s.endIndex)}else{const n=t.targets[t.targetIndex];this.addOrRemoveTracedCoordinates_(n,s.endIndex)}t.targetIndex=s.index;const i=t.targets[t.targetIndex];i.endIndex=s.endIndex}getTraceCandidates_(e){const t=this.getMap(),s=this.pixelTolerance_,i=t.getCoordinateFromPixel([e.pixel[0]-s,e.pixel[1]+s]),n=t.getCoordinateFromPixel([e.pixel[0]+s,e.pixel[1]-s]),r=C([i,n]);return this.traceSource_.getFeaturesInExtent(r)}toggleTraceState_(e){if(!this.traceSource_||!this.traceCondition_(e))return;if(this.traceState_.active){this.deactivateTrace_(),this.traceSegments_=null;return}const t=this.getTraceCandidates_(e);if(t.length===0)return;const s=_t(e.coordinate,t);s.length&&(this.traceState_={active:!0,startCoord:e.coordinate.slice(),targets:s,targetIndex:-1})}addOrRemoveTracedCoordinates_(e,t){const s=e.startIndex<=e.endIndex,i=e.startIndex<=t;s===i?s&&t>e.endIndex||!s&&t<e.endIndex?this.addTracedCoordinates_(e,e.endIndex,t):(s&&t<e.endIndex||!s&&t>e.endIndex)&&this.removeTracedCoordinates_(t,e.endIndex):(this.removeTracedCoordinates_(e.startIndex,e.endIndex),this.addTracedCoordinates_(e,e.startIndex,t))}removeTracedCoordinates_(e,t){if(e===t)return;let s=0;if(e<t){const i=Math.ceil(e);let n=Math.floor(t);n===t&&(n-=1),s=n-i+1}else{const i=Math.floor(e);let n=Math.ceil(t);n===t&&(n+=1),s=i-n+1}if(s>0)for(const i of this.traceSegments_){const n=i[0],r=n.geometry,o=i[1];let a=i[0].index+1;o===1&&(a-=s);const h=r.getCoordinates();Se(h,r.getType(),n.depth).splice(a,s),r.setCoordinates(h),o===1&&(n.index-=s)}}addTracedCoordinates_(e,t,s){if(t===s)return;const i=[];if(t<s){const n=Math.ceil(t);let r=Math.floor(s);r===s&&(r-=1);for(let o=n;o<=r;++o)i.push(k(e.coordinates,o))}else{const n=Math.floor(t);let r=Math.ceil(s);r===s&&(r+=1);for(let o=n;o>=r;--o)i.push(k(e.coordinates,o))}if(i.length)for(const n of this.traceSegments_){const r=n[0],o=r.geometry,a=n[1],h=r.index+1;a===0&&i.reverse();const d=o.getCoordinates();Se(d,o.getType(),r.depth).splice(h,0,...i),o.setCoordinates(d),a===1&&(r.index+=i.length)}}updateGeometry_(e,t){const s=t[0],i=s.depth;let n;const r=s.segment,o=s.geometry,a=t[1];for(;e.length<o.getStride();)e.push(r[a][e.length]);switch(o.getType()){case"Point":n=e,r[0]=e,r[1]=e;break;case"MultiPoint":n=o.getCoordinates(),n[s.index]=e,r[0]=e,r[1]=e;break;case"LineString":n=o.getCoordinates(),n[s.index+a]=e,r[a]=e;break;case"MultiLineString":n=o.getCoordinates(),n[i[0]][s.index+a]=e,r[a]=e;break;case"Polygon":n=o.getCoordinates(),n[i[0]][s.index+a]=e,r[a]=e;break;case"MultiPolygon":n=o.getCoordinates(),n[i[1]][i[0]][s.index+a]=e,r[a]=e;break;case"Circle":const h=o;if(r[0]=e,r[1]=e,s.index===qe)this.changingFeature_=!0,h.setCenter(e),this.changingFeature_=!1;else{this.changingFeature_=!0,this.getMap().getView().getProjection();let d=b(p(h.getCenter()),p(e));h.setRadius(d),this.changingFeature_=!1}break}n&&this.setGeometryCoordinates_(o,n)}handleDragEvent(e){this.ignoreNextSingleClick_=!1,this.willModifyFeatures_(e,this.dragSegments_.map(([r])=>r));const t=[e.coordinate[0]+this.delta_[0],e.coordinate[1]+this.delta_[1]],s=[],i=[],n=this.traceState_.active&&!this.traceSegments_?this.traceState_.startCoord:null;if(n){this.traceSegments_=[];for(const r of this.dragSegments_){const o=r[0];b(Le(n,o.segment),n)/e.map.getView().getResolution()<1&&this.traceSegments_.push(r)}}for(let r=0,o=this.dragSegments_.length;r<o;++r){const a=this.dragSegments_[r],h=a[0],d=h.feature;s.includes(d)||s.push(d);const u=h.geometry;i.includes(u)||i.push(u),this.updateGeometry_(t,a)}this.updateTrace_(e),this.createOrUpdateVertexFeature_(t,s,i,!0)}handleDownEvent(e){if(!this.condition_(e))return!1;const t=e.coordinate,s=this.findInsertVerticesAndUpdateDragSegments_(t);if(s?.length&&this.insertVertexCondition_(e)&&(this.willModifyFeatures_(e,s),this.vertexFeature_)){const i=this.vertexFeature_.getGeometry().getCoordinates();for(let n=s.length-1;n>=0;--n)this.insertVertex_(s[n],i);this.ignoreNextSingleClick_=!0}return!!this.vertexFeature_}handleUpEvent(e){for(let t=this.dragSegments_.length-1;t>=0;--t){const s=this.dragSegments_[t][0],i=s.geometry;if(i.getType()==="Circle"){const n=i,r=n.getCenter(),o=s.featureSegments[0],a=s.featureSegments[1];o.segment[0]=r,o.segment[1]=r,a.segment[0]=r,a.segment[1]=r,this.rBush_.update(pe(r),o);let h=n;this.rBush_.update(h.getExtent(),a)}else this.rBush_.update(C(s.segment),s)}return this.featuresBeingModified_&&(this.toggleTraceState_(e),this.dispatchEvent(new Pe(we.MODIFYEND,this.featuresBeingModified_,e)),this.featuresBeingModified_=null),!1}handlePointerMove_(e){this.lastCoordinate_=e.coordinate,this.handlePointerAtPixel_(this.lastCoordinate_)}handlePointerAtPixel_(e){const t=this.getMap(),s=t.getPixelFromCoordinate(e);t.getView().getProjection();const i=function(o,a){return Ye(e,o)-Ye(e,a)};let n,r;if(this.hitDetection_){const o=typeof this.hitDetection_=="object"?a=>a===this.hitDetection_:void 0;t.forEachFeatureAtPixel(s,(a,h,d)=>{d&&d.getType()==="Point"&&(d=new A(Y(d.getCoordinates())));const u=d||a.getGeometry();if(u&&u.getType()==="Point"&&a instanceof E&&this.features_.getArray().includes(a)){r=u;const c=a.getGeometry().getFlatCoordinates().slice(0,2);n=[{feature:a,geometry:r,segment:[c,c]}]}return!0},{layerFilter:o})}if(!n){const o=ns(pe(e,Xe)),a=t.getView().getResolution()*this.pixelTolerance_,h=ht(lt(o,a,Xe));n=this.rBush_.getInExtent(h)}if(n&&n.length>0){const o=n.sort(i)[0],a=o.segment;let h=He(e,o);const d=t.getPixelFromCoordinate(h);let u=b(s,d);if(r||u<=this.pixelTolerance_){const c={};if(c[S(a)]=!0,this.snapToPointer_||(this.delta_[0]=h[0]-e[0],this.delta_[1]=h[1]-e[1]),o.geometry.getType()==="Circle"&&o.index===q)this.snappedToVertex_=!0,this.createOrUpdateVertexFeature_(h,[o.feature],[o.geometry],this.snappedToVertex_);else{const g=t.getPixelFromCoordinate(a[0]),f=t.getPixelFromCoordinate(a[1]),_=I(d,g),m=I(d,f);if(u=Math.sqrt(Math.min(_,m)),this.snappedToVertex_=u<=this.pixelTolerance_,!this.snappedToVertex_&&!this.insertVertexCondition_(this.lastPointerEvent_)){this.vertexFeature_&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null);return}this.snappedToVertex_&&(h=_>m?a[1]:a[0]),this.createOrUpdateVertexFeature_(h,[o.feature],[o.geometry],this.snappedToVertex_);const y={};y[S(o.geometry)]=!0;for(let x=1,F=n.length;x<F;++x){const B=n[x].segment;if(w(a[0],B[0])&&w(a[1],B[1])||w(a[0],B[1])&&w(a[1],B[0])){const Re=S(n[x].geometry);Re in y||(y[Re]=!0,c[S(B)]=!0)}else break}}this.vertexSegments_=c;return}}this.vertexFeature_&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null)}insertVertex_(e,t){const s=e.segment,i=e.feature,n=e.geometry,r=e.depth,o=e.index;let a;for(;t.length<n.getStride();)t.push(0);switch(n.getType()){case"MultiLineString":a=n.getCoordinates(),a[r[0]].splice(o+1,0,t);break;case"Polygon":a=n.getCoordinates(),a[r[0]].splice(o+1,0,t);break;case"MultiPolygon":a=n.getCoordinates(),a[r[1]][r[0]].splice(o+1,0,t);break;case"LineString":a=n.getCoordinates(),a.splice(o+1,0,t);break;default:return!1}this.setGeometryCoordinates_(n,a);const h=this.rBush_;h.remove(e),this.updateSegmentIndices_(n,o,r,1);const d={segment:[s[0],t],feature:i,geometry:n,depth:r,index:o};h.insert(C(d.segment),d),this.dragSegments_.push([d,1]);const u={segment:[t,s[1]],feature:i,geometry:n,depth:r,index:o+1};return h.insert(C(u.segment),u),this.dragSegments_.push([u,0]),!0}updatePointer_(e){return e&&this.findInsertVerticesAndUpdateDragSegments_(e),this.vertexFeature_?.getGeometry().getCoordinates()}getPoint(){const e=this.vertexFeature_?.getGeometry().getCoordinates();return e?Y(e,this.getMap().getView().getProjection()):null}canRemovePoint(){if(!this.vertexFeature_||this.vertexFeature_.get("geometries").every(s=>s.getType()==="Circle"||s.getType().endsWith("Point")))return!1;const e=this.vertexFeature_.getGeometry().getCoordinates();return this.rBush_.getInExtent(C([e])).some(({segment:s})=>w(s[0],e)||w(s[1],e))}removePoint(e){if(e&&(e=p(e,this.getMap().getView().getProjection()),this.updatePointer_(e)),!this.lastPointerEvent_||this.lastPointerEvent_&&this.lastPointerEvent_.type!=T.POINTERDRAG){const t=this.lastPointerEvent_;this.willModifyFeatures_(t,this.dragSegments_.map(([i])=>i));const s=this.removeVertex_();return this.featuresBeingModified_&&this.dispatchEvent(new Pe(we.MODIFYEND,this.featuresBeingModified_,t)),this.featuresBeingModified_=null,s}return!1}removeVertex_(){const e=this.dragSegments_,t={};let s=!1,i,n,r,o,a,h,d,u,c,g,f;for(a=e.length-1;a>=0;--a)r=e[a],g=r[0],f=S(g.feature),g.depth&&(f+="-"+g.depth.join("-")),f in t||(t[f]={}),r[1]===0?(t[f].right=g,t[f].index=g.index):r[1]==1&&(t[f].left=g,t[f].index=g.index+1);for(f in t){switch(c=t[f].right,d=t[f].left,h=t[f].index,u=h-1,d!==void 0?g=d:g=c,u<0&&(u=0),o=g.geometry,n=o.getCoordinates(),i=n,s=!1,o.getType()){case"MultiLineString":n[g.depth[0]].length>2&&(n[g.depth[0]].splice(h,1),s=!0);break;case"LineString":n.length>2&&(n.splice(h,1),s=!0);break;case"MultiPolygon":i=i[g.depth[1]];case"Polygon":i=i[g.depth[0]],i.length>4&&(h==i.length-1&&(h=0),i.splice(h,1),s=!0,h===0&&(i.pop(),i.push(i[0]),u=i.length-1));break}if(s){this.setGeometryCoordinates_(o,n);const _=[];if(d!==void 0&&(this.rBush_.remove(d),_.push(d.segment[0])),c!==void 0&&(this.rBush_.remove(c),_.push(c.segment[1])),d!==void 0&&c!==void 0){const m={depth:g.depth,feature:g.feature,geometry:g.geometry,index:u,segment:_};this.rBush_.insert(C(m.segment),m)}this.updateSegmentIndices_(o,h,g.depth,-1),this.vertexFeature_&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null),e.length=0}}return s}canInsertPoint(){if(!this.vertexFeature_||this.vertexFeature_.get("geometries").every(s=>s.getType()==="Circle"||s.getType().endsWith("Point")))return!1;const e=this.vertexFeature_.getGeometry().getCoordinates();return this.rBush_.getInExtent(C([e])).some(({segment:s})=>!(w(s[0],e)||w(s[1],e)))}insertPoint(e){const t=e?p(e,this.getMap().getView().getProjection()):this.vertexFeature_?.getGeometry().getCoordinates();return t?this.findInsertVerticesAndUpdateDragSegments_(t).reduce((i,n)=>i||this.insertVertex_(n,t),!1):!1}setGeometryCoordinates_(e,t){this.changingFeature_=!0,e.setCoordinates(t),this.changingFeature_=!1}updateSegmentIndices_(e,t,s,i){this.rBush_.forEachInExtent(e.getExtent(),function(n){n.geometry===e&&(s===void 0||n.depth===void 0||rs(n.depth,s))&&n.index>t&&(n.index+=i)})}}function Gs(l,e){return l.index-e.index}function Ye(l,e,t){const s=e.geometry;if(s.getType()==="Circle"){let n=s;if(e.index===q){const r=I(n.getCenter(),p(l)),o=Math.sqrt(r)-n.getRadius();return o*o}}const i=p(l);return j[0]=p(e.segment[0]),j[1]=p(e.segment[1]),os(i,j)}function He(l,e,t){const s=e.geometry;if(s.getType()==="Circle"&&e.index===q)return Y(s.getClosestPoint(p(l)));const i=p(l);return j[0]=p(e.segment[0]),j[1]=p(e.segment[1]),Y(Le(i,j))}function Ls(){const l=at();return function(e,t){return l.Point}}const Ee={SNAP:"snap",UNSNAP:"unsnap"};class ve extends _e{constructor(e,t){super(e),this.vertex=t.vertex,this.vertexPixel=t.vertexPixel,this.feature=t.feature,this.segment=t.segment}}const pt={Circle(l,e){const s=ds(l);return pt.Polygon(s)},GeometryCollection(l,e){const t=[],s=l.getGeometriesArray();for(let i=0;i<s.length;++i){const n=this[s[i].getType()];n&&t.push(n(s[i],e))}return t.flat()},LineString(l){const e=[],t=l.getFlatCoordinates(),s=l.getStride();for(let i=0,n=t.length-s;i<n;i+=s)e.push([t.slice(i,i+2),t.slice(i+s,i+s+2)]);return e},MultiLineString(l){const e=[],t=l.getFlatCoordinates(),s=l.getStride(),i=l.getEnds();let n=0;for(let r=0,o=i.length;r<o;++r){const a=i[r];for(let h=n,d=a-s;h<d;h+=s)e.push([t.slice(h,h+2),t.slice(h+s,h+s+2)]);n=a}return e},MultiPoint(l){const e=[],t=l.getFlatCoordinates(),s=l.getStride();for(let i=0,n=t.length;i<n;i+=s)e.push([t.slice(i,i+2)]);return e},MultiPolygon(l){const e=[],t=l.getFlatCoordinates(),s=l.getStride(),i=l.getEndss();let n=0;for(let r=0,o=i.length;r<o;++r){const a=i[r];for(let h=0,d=a.length;h<d;++h){const u=a[h];for(let c=n,g=u-s;c<g;c+=s)e.push([t.slice(c,c+2),t.slice(c+s,c+s+2)]);n=u}}return e},Point(l){return[[l.getFlatCoordinates().slice(0,2)]]},Polygon(l){const e=[],t=l.getFlatCoordinates(),s=l.getStride(),i=l.getEnds();let n=0;for(let r=0,o=i.length;r<o;++r){const a=i[r];for(let h=n,d=a-s;h<d;h+=s)e.push([t.slice(h,h+2),t.slice(h+s,h+s+2)]);n=a}return e}};function We(l){return l.feature?l.feature:l.element?l.element:null}const Me=[],P=[],R=[];class As extends fe{constructor(e){e=e||{},super({handleDownEvent:he,stopDown:nt}),this.on,this.once,this.un,this.source_=e.source?e.source:null,this.vertex_=e.vertex!==void 0?e.vertex:!0,this.edge_=e.edge!==void 0?e.edge:!0,this.intersection_=e.intersection!==void 0?e.intersection:!1,this.features_=e.features?e.features:null,this.featuresListenerKeys_=[],this.featureChangeListenerKeys_={},this.indexedFeaturesExtents_={},this.pendingFeatures_={},this.pixelTolerance_=e.pixelTolerance!==void 0?e.pixelTolerance:10,this.rBush_=new ut,this.snapped_=null,this.segmenters_=Object.assign({},pt,e.segmenters)}addFeature(e,t){t=t!==void 0?t:!0;const s=S(e),i=e.getGeometry();if(i){const n=this.segmenters_[i.getType()];if(n){this.indexedFeaturesExtents_[s]=i.getExtent(as());const r=n.call(this.segmenters_,i,this.getMap().getView().getProjection());let o=r.length;for(let a=0;a<o;++a){const h=r[a];P[a]=C(h),R[a]={feature:e,segment:h}}if(this.intersection_)for(let a=0,h=r.length;a<h;++a){const d=r[a];if(d.length===1)continue;const u=P[a];for(let g=0,f=a-1;g<f;++g){const _=r[g];if(!tt(u,P[g]))continue;const m=Ne(d,_);if(!m)continue;const y=[m];P[o]=C(y),R[o++]={feature:e,intersectionFeature:e,segment:y}}const c=this.rBush_.getInExtent(P[a]);for(let g=0,f=c.length;g<f;++g){const _=c[g].segment;if(_.length===1)continue;const m=Ne(d,_);if(!m)continue;const y=[m];P[o]=C(y),R[o++]={feature:e,intersectionFeature:c[g].feature,segment:y}}}o===1?this.rBush_.insert(P[0],R[0]):(P.length=o,R.length=o,this.rBush_.load(P,R))}}t&&(this.featureChangeListenerKeys_[s]&&K(this.featureChangeListenerKeys_[s]),this.featureChangeListenerKeys_[s]=M(e,X.CHANGE,this.handleFeatureChange_,this))}getFeatures_(){let e;return this.features_?e=this.features_:this.source_&&(e=this.source_.getFeatures()),e}areSnapDataEqual_(e,t){return e.segment===t.segment&&e.feature===t.feature}handleEvent(e){const t=this.snapTo(e.pixel,e.coordinate,e.map);return t?(e.coordinate=t.vertex.slice(0,2),e.pixel=t.vertexPixel,this.snapped_&&!this.areSnapDataEqual_(this.snapped_,t)&&this.dispatchEvent(new ve(Ee.UNSNAP,this.snapped_)),this.snapped_={vertex:e.coordinate,vertexPixel:e.pixel,feature:t.feature,segment:t.segment},this.dispatchEvent(new ve(Ee.SNAP,this.snapped_))):this.snapped_&&(this.dispatchEvent(new ve(Ee.UNSNAP,this.snapped_)),this.snapped_=null),super.handleEvent(e)}handleFeatureAdd_(e){const t=We(e);t&&this.addFeature(t)}handleFeatureRemove_(e){const t=We(e);t&&(this.removeFeature(t),delete this.pendingFeatures_[S(t)])}handleFeatureChange_(e){const t=e.target;this.handlingDownUpSequence?this.pendingFeatures_[S(t)]=t:this.updateFeature_(t)}handleUpEvent(e){const t=Object.values(this.pendingFeatures_);if(t.length){for(const s of t)this.updateFeature_(s);hs(this.pendingFeatures_)}return!1}removeFeature(e,t){const s=t!==void 0?t:!0,i=S(e),n=this.indexedFeaturesExtents_[i];if(n){const r=this.rBush_;r.getInExtent(n).forEach(o=>{(e===o.feature||e===o.intersectionFeature)&&r.remove(o)})}s&&(K(this.featureChangeListenerKeys_[i]),delete this.featureChangeListenerKeys_[i])}setMap(e){const t=this.getMap(),s=this.featuresListenerKeys_;let i=this.getFeatures_();if(Array.isArray(i)||(i=i.getArray()),t&&(s.forEach(K),s.length=0,this.rBush_.clear(),Object.values(this.featureChangeListenerKeys_).forEach(K),this.featureChangeListenerKeys_={}),super.setMap(e),e){this.features_?s.push(M(this.features_,le.ADD,this.handleFeatureAdd_,this),M(this.features_,le.REMOVE,this.handleFeatureRemove_,this)):this.source_&&s.push(M(this.source_,de.ADDFEATURE,this.handleFeatureAdd_,this),M(this.source_,de.REMOVEFEATURE,this.handleFeatureRemove_,this));for(const n of i)this.addFeature(n)}}snapTo(e,t,s){s.getView().getProjection();const i=p(t),n=ht(lt(C([i]),s.getView().getResolution()*this.pixelTolerance_)),r=this.rBush_.getInExtent(n),o=r.length;if(o===0)return null;let a,h=1/0,d,u=null;const c=this.pixelTolerance_*this.pixelTolerance_,g=()=>{if(!a)return null;const f=s.getPixelFromCoordinate(a);return I(e,f)>c?null:{vertex:a,vertexPixel:[Math.round(f[0]),Math.round(f[1])],feature:d,segment:u}};if(this.vertex_||this.intersection_){for(let _=0;_<o;++_){const m=r[_];if(m.feature.getGeometry().getType()!=="Circle")for(const y of m.segment){const x=p(y),F=I(i,x);F<h&&(this.intersection_&&m.intersectionFeature||this.vertex_&&!m.intersectionFeature)&&(a=y,h=F,d=m.feature)}}const f=g();if(f)return f}if(this.edge_){for(let _=0;_<o;++_){let m=null;const y=r[_];if(y.feature.getGeometry().getType()==="Circle"){let x=y.feature.getGeometry();m=ls(i,x)}else{const[x,F]=y.segment;F&&(Me[0]=p(x),Me[1]=p(F),m=Le(i,Me))}if(m){const x=I(i,m);x<h&&(a=Y(m),u=y.feature.getGeometry().getType()==="Circle"?null:y.segment,h=x,d=y.feature)}}const f=g();if(f)return f}return null}updateFeature_(e){this.removeFeature(e,!1),this.addFeature(e,!1)}}const Is=l=>e=>l(),Rs=(l,e)=>t=>l(t)?(e(t),!0):!1,bs=l=>{l.forEach(e=>cs(e))};class Vs{constructor(e){this.listenedKey=e,this.eventKeys.push(M(document,"keydown",this.handleKeyDown.bind(this)),M(document,"keyup",this.handleKeyUp.bind(this)))}eventKeys=[];keyDown=!1;keyDownCallback;keyUpCallback;destroy(){bs(this.eventKeys)}isKeyDown(){return this.keyDown}setOnKeyDown(e){this.keyDownCallback=e}setOnKeyUp(e){this.keyUpCallback=e}handleKeyDown(e){e instanceof KeyboardEvent&&e.key===this.listenedKey&&(this.keyDown=!0,this.keyDownCallback&&this.keyDownCallback())}handleKeyUp(e){e instanceof KeyboardEvent&&e.key===this.listenedKey&&(this.keyDown=!1,this.keyUpCallback&&this.keyUpCallback())}}const Os=(l,e)=>{l.get("draw-style-set")||(l.setStyle(e),l.set("draw-style-set",!0))},Ns=new ke,js="olcInteractionGroup";class Ct{map;virtualGroupUid;constructor(e,t){this.map=e,this.virtualGroupUid=t??js}getGroupInteractions(){return this.map.getInteractions().getArray().filter(e=>je(e)===this.virtualGroupUid)}add(e,t){if(this.hasInteraction(e)){console.warn(`Interaction with uid "${e}" already exists in group "${this.virtualGroupUid}"`);return}const s=je(t);if(s){console.warn(`Interaction with uid "${e}" already exists in group "${s}"`);return}t.set(us,e),t.set(Ue,this.virtualGroupUid),this.map.addInteraction(t)}find(e){return this.getGroupInteractions().find(t=>Z(t)===e)}findByIncluding(e){return this.getGroupInteractions().filter(t=>`${Z(t)}`.includes(e))}remove(e){const t=this.find(e);t&&(t.unset(Ue),this.map.removeInteraction(t))}hasInteraction(e){return this.getGroupInteractions().some(t=>Z(t)===e)}setActive(e,t){const s=this.find(t);s&&(e?this.use(s):s.setActive(!1))}deactivateAll(){return this.getGroupInteractions().forEach(e=>e.setActive(!1))}destroy(){this.deactivateAll(),this.getGroupInteractions().forEach(e=>{this.remove(Z(e)??"")})}use(e){this.deactivateAll(),e.setActive(!0)}}const D=gs.createEmptyMap(),ue="layer1-id",Us="background1-id",ge="point-interaction-uid",De="line-interaction-uid",xt="modify-interaction-uid",Bs=new Ae({source:new Ie({features:new N([new E])})}),Ks=new fs({source:new _s}),$e=l=>{document.querySelector("#console .text").textContent=l};D.setView(new ms({center:[0,0],zoom:2}));D.setTarget("map");let U=new gt(D);U.addLayer(Bs,ue);const qs=new ys(D);qs.addLayer(Ks,Us);const oe=new Ct(D,"modifyGroup"),G=new Ct(D,"drawGroup");let ze,Ze,Je,Qe,et,ne;const Xs=[],Ys=()=>{U=new gt(D);const l=U?.getLayer(ue),e=l?.getSource();if(!l||!e||!D){console.error("No layer source or no map to draw in.");return}Os(l,re),ne=new Vs("Delete"),ze=new Ke({source:e,type:"Point",condition:()=>!ne?.isKeyDown(),style:re}),G.add(ge,ze),Ze=new Ke({source:e,type:"LineString",condition:()=>!ne?.isKeyDown(),style:re}),G.add(De,Ze),Je=new Ds({source:e,style:re,deleteCondition:Rs(ps([Fs,Is(()=>ne.isKeyDown())]),Hs.bind(void 0))}),oe.add(xt,Je),Qe=new ks({layers:[l],condition:Cs}),oe.add("translate",Qe),et=new As({source:e}),oe.add("snap",et),Xs.push(G.find(ge)?.on("drawend",()=>{$e("Point added.")}),G.find(De)?.on("drawend",()=>{$e("Line added.")}))},re=l=>{const e=l?.getGeometry(),t=e?.getType();if(["MultiPoint","Point"].includes(`${t}`)&&e){const s=e.getCoordinates()[0]??0,i=Math.round(Math.abs(s)/(20037508/2)*255);return new ke({image:new xs({radius:8,fill:new Ts({color:`rgba(${i}, 0, 0, 0.7)`}),stroke:new Be({color:`rgba(${i}, 0, 0, 0.7)`})})})}else return["LineString","MultiLineString"].includes(`${t}`)&&e?new ke({stroke:new Be({color:"rgba(200, 150, 0, 0.8)",width:4})}):Ns},Hs=l=>{setTimeout(()=>Ws(l),20)},Ws=l=>{l.map.forEachFeatureAtPixel(l.pixel,e=>{if(!U||e instanceof Es)return;const t=e.getGeometry();if(!t||t.getType()==="LineString"&&t.getCoordinates().length>2)return;if((U.getFeaturesCollection(ue)?.getArray()||[]).includes(e)){U.removeFeatures(ue,[e]);const i=oe.find(xt);i?.setActive(!1),i?.setActive(!0)}})};Ys();G.setActive(!0,ge);const $s=document.getElementById("type");$s.addEventListener("change",l=>{l.target.value==="point"?G.setActive(!0,ge):G.setActive(!0,De)});
